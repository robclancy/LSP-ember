"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.patternMatch = patternMatch;
exports.processTemplate = processTemplate;
exports.syntax = void 0;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var syntax = require("@glimmer/syntax");

exports.syntax = syntax;
var preprocess = syntax.preprocess;
var hbsMeta = {
  paths: [],
  modifiers: [],
  arguments: [],
  properties: [],
  components: [],
  links: [],
  helpers: []
};
var HAVE_SEEN_KEY = '_HBS_UTILS_SEEN';
var BLOCKS_STACK = [];

function seen(node) {
  return HAVE_SEEN_KEY in node;
}

function markAsSeen(node) {
  node[HAVE_SEEN_KEY] = true;
}

function addUniqHBSMetaProperty(type, item) {
  if (hbsMeta[type].includes(item)) {
    return;
  }

  if ((type === 'properties' || type === 'paths') && BLOCKS_STACK.length) {
    var itemPart = item.split('.')[0].replace('this.', '').replace('@', '');

    if (BLOCKS_STACK.includes(itemPart)) {
      hbsMeta[type].push('$' + item);
    }
  } else {
    if (type === 'helpers' && BLOCKS_STACK.includes(item)) {
      return;
    }

    hbsMeta[type].push(item);
  }
}

function resetHBSMeta() {
  BLOCKS_STACK = [];
  hbsMeta = {
    paths: [],
    modifiers: [],
    arguments: [],
    properties: [],
    components: [],
    links: [],
    helpers: []
  };
}

function patternMatch(node, pattern) {
  if (Array.isArray(pattern)) {
    for (var i = 0; i < pattern.length; i++) {
      if (patternMatch(node, pattern[i])) {
        return true;
      }
    }

    return false;
  }

  var attrs = Object.keys(pattern);

  for (var _i = 0; _i < attrs.length; _i++) {
    var key = attrs[_i];

    if (_typeof(pattern[key]) === 'object' && pattern[key] !== null) {
      if (key in node) {
        if (!patternMatch(node[key], pattern[key])) {
          return false;
        }
      } else {
        return false;
      }
    } else if (pattern[key] === node[key]) {// return true;
    } else {
      return false;
    }
  }

  return true;
}

function isLinkNode(node) {
  return patternMatch(node, [{
    type: "BlockStatement",
    path: {
      type: "PathExpression",
      original: "link-to"
    }
  }, {
    tag: 'LinkTo',
    type: 'ElementNode'
  }]);
}

function ignoredPaths() {
  return ["hasBlock", "if", "each", "each-in", "else", "component", "yield", "hash", "unless"];
}

function plugin() {
  return {
    visitor: {
      BlockStatement: function BlockStatement(node) {
        if (isLinkNode(node)) {
          var linkPath = node.params[0].original;

          if (!hbsMeta.links.includes(linkPath)) {
            hbsMeta.links.push(linkPath);
          }
        } else if (!node.path.original.includes(".") && !node.path.original.includes("-") && !node.path.original.startsWith('@') && node.path.original !== "component") {
          addUniqHBSMetaProperty("helpers", node.path.original);
        } else if (node.pathOriginal !== "component" && node.path.original.includes("-")) {
          addUniqHBSMetaProperty("components", node.path.original);
        }
      },
      ElementNode: function ElementNode(item) {
        if (item.tag.charAt(0) === item.tag.charAt(0).toUpperCase()) {
          if (isLinkNode(item)) {
            item.attributes.forEach(function (attr) {
              if (attr.name === '@route') {
                if (attr.value.type === 'TextNode') {
                  var linkPath = attr.value.chars;

                  if (!hbsMeta.links.includes(linkPath)) {
                    hbsMeta.links.push(linkPath);
                  }
                }
              }
            });
          } else {
            addUniqHBSMetaProperty("components", item.tag);
          }
        }

        if (item.blockParams && item.blockParams.length) {
          BLOCKS_STACK.push(item.blockParams[0]);
        }
      },
      MustacheStatement: function MustacheStatement(item) {
        var pathName = item.path.original;

        if (pathName === "component" && item.params[0].type === "StringLiteral") {
          addUniqHBSMetaProperty("components", item.params[0].original);
        } else {
          if (pathName === 'link-to') {
            if (item.params.length > 1) {
              if (item.params[1].type === 'StringLiteral') {
                markAsSeen(item);
                hbsMeta.links.push(item.params[1].original);
              }
            }
          } else {
            if (!pathName.includes(".") && !pathName.startsWith('@') && !pathName.includes("-")) {
              addUniqHBSMetaProperty("helpers", item.path.original);
            }
          }
        }
      },
      Block: function Block(node) {
        BLOCKS_STACK.push(node.blockParams[0]);
      },
      SubExpression: function SubExpression(item) {
        if (item.path.original === "component" && item.params[0].type === "StringLiteral") {
          addUniqHBSMetaProperty("components", item.params[0].original);
        } else {
          if (!item.path.original.includes(".") && !item.path.original.startsWith("@") && !item.path.original.includes("-")) {
            addUniqHBSMetaProperty("helpers", item.path.original);
          }
        }
      },
      PathExpression: function PathExpression(item) {
        if (seen(item)) {
          return item;
        }

        var pathOriginal = item.original;

        if (item.data === true && item["this"] === false) {
          addUniqHBSMetaProperty("arguments", pathOriginal);
        } else if (item["this"] === true) {
          if (pathOriginal !== 'this') {
            addUniqHBSMetaProperty("properties", pathOriginal);
          }
        } else {
          if (pathOriginal.includes("/")) {
            addUniqHBSMetaProperty("components", pathOriginal);
          } else if (pathOriginal.includes("-") && !pathOriginal.includes(".")) {
            if (pathOriginal !== 'link-to') {
              addUniqHBSMetaProperty("helpers", pathOriginal);
            }
          } else {
            if (pathOriginal !== 'action') {
              addUniqHBSMetaProperty("paths", pathOriginal);
            }
          }
        }
      },
      ElementModifierStatement: function ElementModifierStatement(item) {
        var name = item.path.original;
        var maybeFirstParam = item.params[0] ? item.params[0].original : '';
        markAsSeen(item.path);
        hbsMeta.modifiers.push({
          name: name,
          param: maybeFirstParam
        });
      }
    }
  };
}

function processTemplate(template) {
  resetHBSMeta();
  preprocess(template, {
    plugins: {
      ast: [plugin]
    }
  });
  var ignored = ignoredPaths();
  var allStuff = Object.keys(hbsMeta).filter(function (key) {
    return key !== "paths";
  }).reduce(function (result, key) {
    return result.concat(hbsMeta[key]);
  }, []);
  hbsMeta.paths = hbsMeta.paths.filter(function (p) {
    return !allStuff.includes(p);
  }).filter(function (p) {
    return !ignored.includes(p);
  });
  hbsMeta.helpers = hbsMeta.helpers.filter(function (n) {
    return !hbsMeta.components.includes(n) && !ignored.includes(n);
  });
  hbsMeta.properties = hbsMeta.properties.filter(function (p) {
    return !ignored.includes(p);
  });
  return JSON.parse(JSON.stringify(hbsMeta));
}