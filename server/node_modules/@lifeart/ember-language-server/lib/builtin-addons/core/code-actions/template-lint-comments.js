"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("vscode-languageserver/node");
const logger_1 = require("../../../utils/logger");
const estree_utils_1 = require("../../../estree-utils");
const glimmer_utils_1 = require("../../../glimmer-utils");
const recast = require("ember-template-recast");
const base_1 = require("./base");
class TemplateLintCommentsCodeAction extends base_1.default {
    fixTemplateLintIssuesWithComment(commentableIssues, params, meta) {
        return commentableIssues.map((issue) => {
            if (!meta.selection) {
                return null;
            }
            try {
                const result = this.commentCodeAction(meta, `template-lint-disable ${issue.code}`);
                if (result === meta.selection) {
                    return null;
                }
                const edit = {
                    changes: {
                        [params.textDocument.uri]: [node_1.TextEdit.replace((0, estree_utils_1.toLSRange)(meta.location), result)],
                    },
                };
                return node_1.CodeAction.create(`disable: ${issue.code}`, edit, node_1.CodeActionKind.QuickFix);
            }
            catch (e) {
                (0, logger_1.logError)(e);
                return null;
            }
        });
    }
    commentCodeAction(meta, comment) {
        const transform = recast.transform;
        const seen = new Set();
        const offset = new Array(meta.location.start.column).fill(' ').join('');
        const template = `${offset}${meta.selection}`;
        const { code } = transform({
            template,
            plugin(env) {
                const { builders: b } = env.syntax;
                let items = 0;
                function addComment(node, el) {
                    if (seen.has(node) || items > 0 || !el.parent || !el.parent.node) {
                        return;
                    }
                    seen.add(node);
                    const parentNode = el.parent.node;
                    const children = parentNode.children || parentNode.body;
                    if (children && node.loc) {
                        items++;
                        const loc = (0, glimmer_utils_1.nodeLoc)(node);
                        const startColumn = loc.start.column;
                        const text = ` ${comment} `;
                        const textComment = '\n' + new Array(startColumn).fill(' ').join('');
                        children.splice(children.indexOf(node), 0, b.mustacheComment(text));
                        children.splice(children.indexOf(node), 0, b.text(textComment));
                    }
                }
                return {
                    ElementNode(node, nodePath) {
                        addComment(node, nodePath);
                    },
                    BlockStatement(node, nodePath) {
                        addComment(node, nodePath);
                    },
                    MustacheStatement(node, nodePath) {
                        addComment(node, nodePath);
                    },
                };
            },
        });
        return code.trimLeft();
    }
    async onCodeAction(_, params) {
        const diagnostics = params.context.diagnostics;
        const commentableIssues = diagnostics.filter((el) => el.source === 'ember-template-lint' && !el.message.endsWith('(fixable)') && el.code);
        if (commentableIssues.length === 0) {
            return null;
        }
        try {
            const meta = this.metaForRange(params);
            if (!meta) {
                return null;
            }
            const fixedIssues = await this.fixTemplateLintIssuesWithComment(commentableIssues, params, meta);
            const codeActions = fixedIssues.filter((el) => el !== null);
            return codeActions;
        }
        catch (e) {
            return null;
        }
    }
}
exports.default = TemplateLintCommentsCodeAction;
//# sourceMappingURL=template-lint-comments.js.map