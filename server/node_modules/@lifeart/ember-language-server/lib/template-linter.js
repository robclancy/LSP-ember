"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("vscode-languageserver/node");
const file_extension_1 = require("./utils/file-extension");
const diagnostic_1 = require("./utils/diagnostic");
const ember_extract_inline_templates_1 = require("@lifeart/ember-extract-inline-templates");
const ember_meta_explorer_1 = require("ember-meta-explorer");
const vscode_uri_1 = require("vscode-uri");
const logger_1 = require("./utils/logger");
const url_1 = require("url");
const layout_helpers_1 = require("./utils/layout-helpers");
const glimmer_script_1 = require("./utils/glimmer-script");
class Linter {
    constructor() {
        return this;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    verify(_params) {
        return [];
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    verifyAndFix(_params) {
        return {
            output: '',
            isFixed: true,
        };
    }
}
const extensionsToLint = ['.hbs', '.js', '.ts', '.gts', '.gjs'];
function setCwd(cwd) {
    try {
        process.chdir(cwd);
    }
    catch (err) {
        (0, logger_1.logError)(err);
    }
}
class TemplateLinter {
    constructor(server) {
        this.server = server;
        this._linterCache = new Map();
        this._isEnabled = true;
        if (this.server.options.type === 'worker') {
            this.disable();
        }
    }
    disable() {
        this._isEnabled = false;
    }
    enable() {
        this._isEnabled = true;
    }
    get isEnabled() {
        return this._isEnabled;
    }
    getProjectForDocument(textDocument) {
        const ext = (0, file_extension_1.getExtension)(textDocument);
        if (ext !== null && !extensionsToLint.includes(ext)) {
            return;
        }
        return this.server.projectRoots.projectForUri(textDocument.uri);
    }
    sourcesForDocument(textDocument, templateLintVersion) {
        const ext = (0, file_extension_1.getExtension)(textDocument);
        if (ext !== null && !extensionsToLint.includes(ext)) {
            return [];
        }
        const documentContent = textDocument.getText();
        // we assume that ember-template-lint v5 could handle js/ts/gts/gjs files
        if (templateLintVersion === '5') {
            return [documentContent];
        }
        if (ext === '.hbs') {
            if (documentContent.trim().length === 0) {
                return [];
            }
            else {
                return [documentContent];
            }
        }
        else if (ext === '.gjs' || ext === '.gts') {
            const ranges = (0, glimmer_script_1.getFileRanges)(documentContent);
            const rangeWalker = new glimmer_script_1.RangeWalker(ranges);
            const templates = rangeWalker.templates();
            return templates.map((t) => {
                return (0, diagnostic_1.toHbsSource)({
                    startLine: t.loc.start.line,
                    startColumn: t.loc.start.character,
                    endColumn: t.loc.end.character,
                    endLine: t.loc.end.line,
                    template: t.content,
                });
            });
        }
        else {
            const nodes = (0, ember_extract_inline_templates_1.getTemplateNodes)(documentContent, {
                parse(source) {
                    return (0, ember_meta_explorer_1.parseScriptFile)(source);
                },
            });
            const sources = nodes.filter((el) => {
                return el.template.trim().length > 0;
            });
            return sources.map((el) => {
                return (0, diagnostic_1.toHbsSource)(el);
            });
        }
    }
    async lint(textDocument) {
        if (this._isEnabled === false) {
            return;
        }
        const cwd = process.cwd();
        const project = this.getProjectForDocument(textDocument);
        if (!project) {
            return;
        }
        const linterMeta = project.dependenciesMeta.find((dep) => dep.name === 'ember-template-lint');
        const linterVersion = (linterMeta === null || linterMeta === void 0 ? void 0 : linterMeta.version.split('.')[0]) || 'unknown';
        let sources = [];
        try {
            sources = this.sourcesForDocument(textDocument, linterVersion);
        }
        catch (e) {
            return;
        }
        if (!sources.length) {
            return;
        }
        const TemplateLinterKlass = await this.getLinter(project);
        if (!TemplateLinterKlass) {
            return;
        }
        let linter;
        try {
            setCwd(project.root);
            linter = new TemplateLinterKlass();
        }
        catch (e) {
            try {
                setCwd(cwd);
            }
            catch (e) {
                (0, logger_1.logDebugInfo)(e.stack);
            }
            return;
        }
        let diagnostics = [];
        try {
            const results = await Promise.all(sources.map(async (source) => {
                const errors = await Promise.resolve(linter.verify({
                    source,
                    moduleId: vscode_uri_1.URI.parse(textDocument.uri).fsPath,
                    filePath: vscode_uri_1.URI.parse(textDocument.uri).fsPath,
                }));
                return errors.map((error) => (0, diagnostic_1.toDiagnostic)(source, error));
            }));
            results.forEach((result) => {
                diagnostics = [...diagnostics, ...result];
            });
        }
        catch (e) {
            (0, logger_1.logError)(e);
        }
        try {
            setCwd(cwd);
        }
        catch (e) {
            (0, logger_1.logDebugInfo)(e.stack);
        }
        return diagnostics;
    }
    async getFindUp() {
        if (!this._findUp) {
            const { findUp } = await eval(`import('find-up')`);
            this._findUp = findUp;
        }
        return this._findUp;
    }
    async templateLintConfig(cwd) {
        const findUp = await this.getFindUp();
        return findUp('.template-lintrc.js', { cwd, type: 'file' });
    }
    async projectNodeModules(cwd) {
        const findUp = await this.getFindUp();
        return findUp('node_modules', { cwd, type: 'directory' });
    }
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    async linterForProject(project) {
        return await this.getLinter(project);
    }
    // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
    async getLinter(project) {
        if (this._linterCache.has(project)) {
            return this._linterCache.get(project);
        }
        try {
            // don't resolve template-lint (due to resolution error) if no linter config found;
            if (!(await this.templateLintConfig(project.root))) {
                return;
            }
            if (!(0, layout_helpers_1.getRequireSupport)()) {
                return;
            }
            const nodePath = await this.projectNodeModules(project.root);
            if (!nodePath || !(await this.server.fs.exists(nodePath))) {
                return;
            }
            const linterPath = await node_1.Files.resolveModulePath(project.root, 'ember-template-lint', nodePath, () => {
                /* intentially empty default callback */
            });
            if (!linterPath) {
                return;
            }
            try {
                // commonjs behavior
                // @ts-expect-error @todo - fix webpack imports
                const requireFunc = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;
                // eslint-disable-next-line @typescript-eslint/no-var-requires
                const linter = requireFunc(linterPath);
                this._linterCache.set(project, linter);
                return linter;
            }
            catch (_a) {
                // ember-template-lint v4 support (as esm module)
                // using eval here to stop webpack from bundling it
                const linter = (await eval(`import("${(0, url_1.pathToFileURL)(linterPath)}")`)).default;
                this._linterCache.set(project, linter);
                return linter;
            }
        }
        catch (error) {
            (0, logger_1.log)('Module ember-template-lint not found. ' + error.toString());
        }
    }
}
exports.default = TemplateLinter;
//# sourceMappingURL=template-linter.js.map