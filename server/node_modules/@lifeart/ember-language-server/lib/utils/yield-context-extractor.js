"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractYeildMetadata = void 0;
function extractYeildMetadata(template) {
    class Extractors {
        constructor() {
            this.set = new Set();
        }
        Program(node) {
            return this.Template(node);
        }
        ElementModifierStatement(node) {
            return this.SubExpression(node);
        }
        Block(node) {
            return {
                params: node.blockParams.map((p) => p),
                body: this.map(node.body).filter((e) => typeof e !== 'string'),
            };
        }
        StringLiteral(node) {
            return node.original;
        }
        TextNode(node) {
            return node.chars;
        }
        NumberLiteral(node) {
            return node.original;
        }
        NullLiteral(node) {
            return node.original;
        }
        BooleanLiteral(node) {
            return node.original;
        }
        UndefinedLiteral(node) {
            return node.original;
        }
        PathExpression(node) {
            return node.original;
        }
        Hash(node) {
            const acc = {};
            return node.pairs
                .map((pair) => {
                return this.HashPair(pair);
            })
                .reduce((acc, curr) => {
                acc[curr.key] = curr.value;
                return acc;
            }, acc);
        }
        HashPair(node) {
            return {
                key: node.key,
                value: this[node.value.type](node.value),
            };
        }
        AttrNode(node) {
            return [node.name, this[node.value.type](node.value)];
        }
        ElementNode(node) {
            const acc = {};
            return {
                $elemant: node.tag,
                $attributes: this.map(node.attributes).reduce((acc, [key, val]) => {
                    Object.defineProperty(acc, key, {
                        value: val,
                    });
                    return acc;
                }, acc),
                $modifiers: this.map(node.modifiers),
                $programms: this.map(node.children).filter((e) => typeof e !== 'string'),
            };
        }
        Template(node) {
            return {
                $programms: this.map(node.body).filter((e) => typeof e !== 'string'),
            };
        }
        ConcatStatement(node) {
            return this.map(node.parts);
        }
        PartialStatement(node) {
            return node.name;
        }
        CommentStatement(node) {
            return node.value;
        }
        MustacheCommentStatement(node) {
            return node.value;
        }
        Expression(node) {
            return this[node.type](node);
        }
        SubExpression(node) {
            const name = this[node.path.type](node.path);
            const hash = this.Hash(node.hash);
            const params = this.map(node.params);
            if (name === 'hash') {
                return hash;
            }
            if (name === 'array') {
                return params;
            }
            const result = {
                $fn: name,
            };
            if (node.params.length) {
                result.$params = params;
            }
            if (node.hash.pairs.length) {
                result.$hash = hash;
            }
            this.set.add(result);
            return result;
        }
        MustacheStatement(node) {
            return this.SubExpression(node);
        }
        BlockStatement(node) {
            const result = this.SubExpression(node);
            const $programms = [this.Block(node.program)];
            if (node.inverse) {
                $programms.push(this.Block(node.inverse));
            }
            Object.defineProperty(result, '$programms', {
                value: $programms,
            });
            return result;
        }
        map(items) {
            if (!Array.isArray(items)) {
                return [];
            }
            return items.map((p) => {
                if (typeof this[p.type] !== 'function') {
                    throw new Error(p.type);
                }
                return this[p.type](p);
            });
        }
    }
    const extractors = new Extractors();
    extractors.Template(template); // todo, check if this is correct
    const items = Array.from(extractors.set);
    const yields = items.filter((e) => e.$fn == 'yield');
    const cases = {};
    function getCase(value) {
        var _a, _b, _c;
        if (value.$fn === 'component' || value.$fn === 'helper' || value.$fn === 'modifier') {
            const param = (_a = value.$params) === null || _a === void 0 ? void 0 : _a[0];
            const fns = ['or', 'if', 'unless', 'and'];
            if (typeof param === 'string') {
                return [value.$fn, param];
            }
            else if (param && fns.includes(param.$fn)) {
                const names = [];
                (_b = param.$params) === null || _b === void 0 ? void 0 : _b.forEach((el) => {
                    if (typeof el === 'string' && !el.includes('.') && !el.startsWith('@')) {
                        names.push(el);
                    }
                });
                return [value.$fn, names];
            }
            else if (param && param.$fn === 'if') {
                const names = [];
                (_c = param.$params) === null || _c === void 0 ? void 0 : _c.forEach((el) => {
                    if (typeof el === 'string' && !el.includes('.') && !el.startsWith('@')) {
                        names.push(el);
                    }
                });
                return [value.$fn, names];
            }
        }
        return null;
    }
    yields.forEach((el) => {
        var _a;
        (_a = el.$params) === null || _a === void 0 ? void 0 : _a.forEach((p, index) => {
            var _a, _b;
            const isObject = typeof p === 'object' && p !== null && !Array.isArray(p);
            const isPOJO = isObject && !('$fn' in p);
            if (isPOJO) {
                Object.keys(p).forEach((key) => {
                    var _a, _b;
                    const itemKey = `${(_b = (_a = el.$hash) === null || _a === void 0 ? void 0 : _a.to) !== null && _b !== void 0 ? _b : 'default'}:${index}:${key}`;
                    const value = p[key];
                    cases[itemKey] = getCase(value);
                });
            }
            else if (isObject) {
                const itemKey = `${(_b = (_a = el.$hash) === null || _a === void 0 ? void 0 : _a.to) !== null && _b !== void 0 ? _b : 'default'}:${index}:`;
                cases[itemKey] = getCase(p);
            }
        });
    });
    return cases;
}
exports.extractYeildMetadata = extractYeildMetadata;
//# sourceMappingURL=yield-context-extractor.js.map