"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFocusPath = exports.createFocusPath = exports.getTextForGuessing = exports.extensionsToProvideTemplateCompletions = exports.PLACEHOLDER = void 0;
const glimmer_utils_1 = require("../glimmer-utils");
const estree_utils_1 = require("../estree-utils");
const file_extension_1 = require("../utils/file-extension");
const logger_1 = require("../utils/logger");
const ember_extract_inline_templates_1 = require("@lifeart/ember-extract-inline-templates");
const ember_meta_explorer_1 = require("ember-meta-explorer");
const syntax_1 = require("@glimmer/syntax");
exports.PLACEHOLDER = 'ELSCompletionDummy';
exports.extensionsToProvideTemplateCompletions = ['.hbs', '.js', '.ts', '.gjs', '.gts'];
function getTextForGuessing(originalText, offset, PLACEHOLDER) {
    // logDebugInfo('getTextForGuessing', originalText, offset, PLACEHOLDER);
    return originalText.slice(0, offset) + PLACEHOLDER + originalText.slice(offset);
}
exports.getTextForGuessing = getTextForGuessing;
function createFocusPath(ast, position, validText) {
    return glimmer_utils_1.default.toPosition(ast, position, validText);
}
exports.createFocusPath = createFocusPath;
function getFocusPath(document, position, placeholder = exports.PLACEHOLDER) {
    const documentContent = document.getText();
    const ext = (0, file_extension_1.getExtension)(document);
    if (!exports.extensionsToProvideTemplateCompletions.includes(ext)) {
        return null;
    }
    const isHBS = ext === '.hbs' || document.languageId === 'html' || document.languageId === 'handlebars' || document.languageId === 'html.handlebars';
    const originalText = isHBS
        ? documentContent
        : (0, ember_extract_inline_templates_1.searchAndExtractHbs)(documentContent, {
            parse(source) {
                return (0, ember_meta_explorer_1.parseScriptFile)(source);
            },
        });
    (0, logger_1.logDebugInfo)('originalText', originalText);
    if (originalText.trim().length === 0) {
        (0, logger_1.logDebugInfo)('originalText - empty');
        return null;
    }
    const offset = document.offsetAt(position);
    let normalPlaceholder = placeholder;
    let ast = null;
    const cases = [
        exports.PLACEHOLDER + ' />',
        exports.PLACEHOLDER,
        exports.PLACEHOLDER + '"',
        exports.PLACEHOLDER + "'",
        // block params autocomplete
        exports.PLACEHOLDER + '| />',
        exports.PLACEHOLDER + '}} />',
        exports.PLACEHOLDER + '"}}',
        exports.PLACEHOLDER + '}}',
        exports.PLACEHOLDER + '}}{{/' + exports.PLACEHOLDER + '}}',
        // {{#}} -> {{# + P}}{{/P + }}
        exports.PLACEHOLDER + '}}{{/' + exports.PLACEHOLDER,
        exports.PLACEHOLDER + ')}}',
        exports.PLACEHOLDER + '))}}',
        exports.PLACEHOLDER + ')))}}',
    ];
    let validText = '';
    while (cases.length) {
        normalPlaceholder = cases.shift();
        try {
            validText = getTextForGuessing(originalText, offset, normalPlaceholder);
            ast = (0, syntax_1.preprocess)(validText);
            (0, logger_1.logDebugInfo)('validText', validText);
            break;
        }
        catch (e) {
            // logDebugInfo('parsing-error', this.getTextForGuessing(originalText, offset, normalPlaceholder));
            ast = null;
        }
    }
    if (ast === null) {
        return null;
    }
    const focusPath = createFocusPath(ast, (0, estree_utils_1.toPosition)(position), validText);
    if (!focusPath) {
        return null;
    }
    return {
        ast,
        focusPath,
        originalText,
        normalPlaceholder,
    };
}
exports.getFocusPath = getFocusPath;
//# sourceMappingURL=glimmer-template.js.map