"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateTemplateTokens = exports.getAllTemplateTokens = exports.waitForTokensToBeCollected = exports.findRelatedFiles = exports.closestParentRoutePath = void 0;
const template_tokens_collector_1 = require("./template-tokens-collector");
const fs_provider_1 = require("../fs-provider");
const logger_1 = require("./logger");
const syntax_1 = require("@glimmer/syntax");
const yield_context_extractor_1 = require("./yield-context-extractor");
const TEMPLATE_TOKENS = {
    component: {},
    routePath: {},
};
function closestParentRoutePath(name) {
    const lastIndexOfDot = name.lastIndexOf('/');
    if (name.endsWith('-loading') || name.endsWith('-error')) {
        return name.slice(0, name.lastIndexOf('-'));
    }
    if (lastIndexOfDot === undefined || lastIndexOfDot < 0) {
        return null;
    }
    return name.slice(0, lastIndexOfDot);
}
exports.closestParentRoutePath = closestParentRoutePath;
function findRelatedFiles(token, tokenType = 'component') {
    const results = [];
    Object.keys(TEMPLATE_TOKENS).forEach((kindName) => {
        const components = TEMPLATE_TOKENS[kindName];
        Object.keys(components).forEach((normalizedComponentName) => {
            if (components[normalizedComponentName].tokens.includes(token)) {
                results.push({
                    name: normalizedComponentName,
                    path: components[normalizedComponentName].source,
                    type: kindName,
                    usages: [],
                });
            }
        });
    });
    if (tokenType === 'template') {
        const routeTemplates = TEMPLATE_TOKENS.routePath;
        let parent = token;
        do {
            parent = closestParentRoutePath(parent);
            if (parent !== null) {
                const normalizedParentName = parent.split('/').join('.');
                if (routeTemplates[normalizedParentName]) {
                    results.push({
                        name: normalizedParentName,
                        path: routeTemplates[normalizedParentName].source,
                        type: 'routePath',
                        usages: [],
                    });
                    break;
                }
            }
            else {
                break;
            }
        } while (parent);
        if (results.length === 0 && token !== 'application') {
            if (routeTemplates['application']) {
                results.push({
                    name: 'application',
                    path: routeTemplates['application'].source,
                    type: 'routePath',
                    usages: [],
                });
            }
        }
    }
    return results;
}
exports.findRelatedFiles = findRelatedFiles;
const tokenQueue = [];
let extractionTimeout;
function scheduleTokensExtraction(kind, normalizedName, file) {
    tokenQueue.push([kind, normalizedName, file]);
    clearTimeout(extractionTimeout);
    extractionTimeout = setTimeout(extractTokens, 100);
}
async function waitForTokensToBeCollected() {
    while (tokenQueue.length) {
        await new Promise((resolve) => setTimeout(resolve, 200));
    }
}
exports.waitForTokensToBeCollected = waitForTokensToBeCollected;
function getAllTemplateTokens() {
    return TEMPLATE_TOKENS;
}
exports.getAllTemplateTokens = getAllTemplateTokens;
async function extractTokens() {
    if (!tokenQueue.length) {
        return;
    }
    const item = tokenQueue[0];
    if (item === undefined) {
        (0, logger_1.logDebugInfo)('extractTokens:item:undefined', tokenQueue);
        return;
    }
    const [kind, normalizedName, file] = item;
    try {
        const content = await (0, fs_provider_1.fsProvider)().readFile(file);
        if (content !== null && content.trim().length > 0) {
            const ast = (0, syntax_1.preprocess)(content);
            const tokens = (0, template_tokens_collector_1.extractTokensFromTemplate)(ast);
            let yieldMeta = {};
            if (kind === 'component' && content.includes('{{yield')) {
                try {
                    yieldMeta = (0, yield_context_extractor_1.extractYeildMetadata)(ast);
                }
                catch (e) {
                    yieldMeta = {};
                }
            }
            TEMPLATE_TOKENS[kind][normalizedName] = {
                source: file,
                tokens,
                yieldScopes: yieldMeta,
            };
        }
        else if (typeof content === 'string') {
            TEMPLATE_TOKENS[kind][normalizedName] = {
                source: file,
                tokens: [],
                yieldScopes: {},
            };
        }
    }
    catch (e) {
        //
    }
    finally {
        tokenQueue.shift();
        setTimeout(extractTokens, 16);
    }
}
function updateTemplateTokens(kind, normalizedName, file) {
    if (file === null) {
        delete TEMPLATE_TOKENS[kind][normalizedName];
        return;
    }
    scheduleTokensExtraction(kind, normalizedName, file);
}
exports.updateTemplateTokens = updateTemplateTokens;
//# sourceMappingURL=usages-api.js.map