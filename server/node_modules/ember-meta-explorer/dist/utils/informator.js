"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractComponentInformationFromMeta = extractComponentInformationFromMeta;
exports.rebelObject = rebelObject;

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function rebelObject(paths) {
  var obj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  paths.forEach(function (name) {
    if (name === "this") {
      return;
    }

    if (name.startsWith("this.")) {
      name = name.replace("this.", "");
    }

    var ctx = obj;

    if (name.startsWith("@")) {
      name = name.replace("@", "");

      if (!("args" in obj)) {
        obj["args"] = {};
      }

      ctx = obj.args;
    }

    var dotIndex = name.indexOf(".");

    if (dotIndex === -1) {
      if (!(name in ctx)) {
        ctx[name] = "any";
      }
    } else {
      var objKey = name.slice(0, dotIndex);
      var objKeyTail = name.slice(dotIndex + 1, name.length);

      if (_typeof(ctx[objKey]) !== "object") {
        ctx[objKey] = {};
      }

      if (objKeyTail.length) {
        rebelObject([objKeyTail], ctx[objKey]);
      }
    }
  });
  return obj;
}

function eachValue(arr, cb) {
  if (!arr || !Array.isArray(arr)) {
    return;
  }

  arr.forEach(cb);
}

function extractComponentInformationFromMeta(meta) {
  if (!meta) {
    return null;
  }

  var componentInformation = {
    name: "<COMPONENT_NAME",
    jsProps: [],
    jsComputeds: [],
    jsFunc: [],
    jsImports: [],
    hbsComponents: [],
    hbsProps: [],
    hbsHelpers: [],
    api: {
      actions: [],
      tagName: "div",
      attributeBindings: [],
      mergedProperties: [],
      classNameBindings: [],
      concatenatedProperties: [],
      positionalParams: [],
      classNames: []
    }
  }; // const meta = fileMeta.paths.reduce((result, it) => {
  //   Object.keys(it.meta).forEach(name => {
  //     if (name in result) {
  //       result[name] = result[name].concat(it.meta[name]);
  //     } else {
  //       result[name] = it.meta[name];
  //     }
  //   });
  //   return result;
  // }, {});

  if (!("unknownProps" in meta)) {
    meta.unknownProps = [];
  }

  eachValue(meta.computeds, function (value) {
    componentInformation.jsComputeds.push(value);
  });
  eachValue(meta.props, function (value) {
    componentInformation.jsProps.push(value);
  });
  eachValue(meta.functions, function (value) {
    componentInformation.jsFunc.push(value);
  });
  eachValue(meta.actions, function (value) {
    componentInformation.api.actions.push(value);
  });
  eachValue(meta.tagNames, function (value) {
    componentInformation.api.tagName = value;
  });
  eachValue(meta.attributeBindings, function (value) {
    componentInformation.api.attributeBindings.push(value);
  });
  eachValue(meta.classNames, function (value) {
    componentInformation.api.classNames.push(value);
  });
  eachValue(meta.mergedProperties, function (value) {
    componentInformation.api.mergedProperties.push(value);
  });
  eachValue(meta.concatenatedProperties, function (value) {
    componentInformation.api.concatenatedProperties.push(value);
  });
  eachValue(meta.positionalParams, function (value) {
    componentInformation.api.positionalParams.push(value);
  });
  eachValue(meta.classNameBindings, function (value) {
    componentInformation.api.classNameBindings.push(value);
  });
  eachValue(meta.components, function (value) {
    componentInformation.hbsComponents.push(value);
  });
  eachValue(meta.helpers, function (value) {
    componentInformation.hbsHelpers.push(value);
  });
  eachValue(meta.paths, function (value) {
    componentInformation.hbsProps.push(value);
  });
  eachValue(meta.imports, function (value) {
    componentInformation.jsImports.push(value);
  });
  eachValue(meta.properties, function (value) {
    var localName = value.split(".")[1]; // @danger!

    meta.unknownProps.push(localName);
    componentInformation.hbsProps.push(value);
  });
  eachValue(meta.arguments, function (value) {
    var localName = value.split(".")[0].replace("@", ""); // @danger!

    meta.unknownProps.push(localName);
    componentInformation.hbsProps.push(value);
  });
  eachValue(meta.unknownProps, function (rawName) {
    // currentMedia.[]
    if (!rawName) {
      return;
    }

    var propName = rawName.split(".")[0];
    var existingProps = componentInformation.jsProps.filter(function (name) {
      return name.startsWith(propName + " ");
    });

    if (!existingProps.length) {
      var _value = "undefined";

      if (rawName.includes(".[]") || rawName.endsWith(".length")) {
        if (rawName.split(".").length === 2) {
          _value = "[...]";
        }
      } else if (rawName.includes("{")) {
        _value = "{...}";
      } else if (rawName.includes(".@each")) {
        if (rawName.split(".").length === 3) {
          _value = "[{..}]";
        }
      } else if (rawName.includes(".") && !rawName.includes("[") && !rawName.includes("{")) {
        _value = "{...}";
      }

      componentInformation.jsProps.push("".concat(propName, " = ").concat(_value));
    }
  });
  componentInformation.jsProps.sort(function (a, b) {
    if (a.endsWith("= undefined") && !b.endsWith("= undefined")) {
      return -1;
    } else if (!a.endsWith("= undefined") && b.endsWith("= undefined")) {
      return 1;
    }

    if (a.includes("(") && !b.includes("(")) {
      return -1;
    } else if (!a.includes("(") && b.includes("(")) {
      return 1;
    }

    if (a.charAt(0) === b.charAt(0)) {
      var diff = a.split(" ")[0].length - b.split(" ")[0].length;

      if (diff !== 0) {
        return diff;
      }
    }

    return a.split(" ")[0].localeCompare(b.split(" ")[0]);
  });
  componentInformation.jsComputeds.sort(function (a, b) {
    if (a.endsWith("= undefined") && !b.endsWith("= undefined")) {
      return -1;
    } else if (!a.endsWith("= undefined") && b.endsWith("= undefined")) {
      return 1;
    }

    if (a.includes("(") && !b.includes("(")) {
      return -1;
    } else if (!a.includes("(") && b.includes("(")) {
      return 1;
    }

    if (a.charAt(0) === b.charAt(0)) {
      var diff = a.split(" ")[0].length - b.split(" ")[0].length;

      if (diff !== 0) {
        return diff;
      }
    }

    return a.split(" ")[0].localeCompare(b.split(" ")[0]);
  });
  componentInformation.jsFunc.sort(function (a, b) {
    var diff = a.split("(")[0].length - b.split("(")[0].length;

    if (diff !== 0) {
      return diff;
    }

    return a.split("(")[0].localeCompare(b.split("(")[0]);
  });
  componentInformation.api.actions.sort();
  componentInformation.api.attributeBindings.sort();
  componentInformation.hbsProps = componentInformation.hbsProps.map(function (name) {
    var path = name.split(".")[0];
    var hasJsProp = componentInformation.jsProps.filter(function (name) {
      return name.startsWith(path + " ");
    });
    var hasComputed = componentInformation.jsComputeds.filter(function (name) {
      return name.startsWith(path + " ");
    });
    var hasJsFunc = componentInformation.jsFunc.filter(function (name) {
      return name.startsWith(path);
    });

    if (hasJsProp.length) {
      return "".concat(name, " as this.").concat(hasJsProp[0]);
    } else if (hasComputed.length) {
      return "".concat(name, " as this.").concat(hasComputed[0]);
    } else if (hasJsFunc.length) {
      return "".concat(name, " as this.").concat(hasJsFunc[0]);
    } else {
      if (name !== "this") {
        if (name.includes(".") && !name.startsWith("@") && !name.startsWith("this.")) {
          componentInformation.jsProps.push("".concat(name.split(".")[0], " = undefined // (used in template)"));
        } else {
          componentInformation.jsProps.push("".concat(name, " = undefined // (used in template)"));
        }

        return "".concat(name, " as used in template");
      } else {
        return name;
      }
    }
  });
  return componentInformation;
}