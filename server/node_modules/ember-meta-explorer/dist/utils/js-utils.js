"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseScriptFile = parseScriptFile;
exports.processJSFile = processJSFile;

var _core = require("@babel/core");

var _traverse = _interopRequireDefault(require("@babel/traverse"));

var _path = require("path");

var _fs = require("fs");

var _fileUtils = require("./file-utils");

var presetTypeScript = _interopRequireWildcard(require("@babel/preset-typescript"));

var proposalDecorators = _interopRequireWildcard(require("@babel/plugin-proposal-decorators"));

var proposalClassProperties = _interopRequireWildcard(require("@babel/plugin-proposal-class-properties"));

var proposalObjectRestSpread = _interopRequireWildcard(require("@babel/plugin-proposal-object-rest-spread"));

var proposalOptionalChaining = _interopRequireWildcard(require("@babel/plugin-proposal-optional-chaining"));

var proposalNullishCoalescingOperator = _interopRequireWildcard(require("@babel/plugin-proposal-nullish-coalescing-operator"));

var proposalNumericSeparator = _interopRequireWildcard(require("@babel/plugin-proposal-numeric-separator"));

var proposalLogicalAssignmentOperators = _interopRequireWildcard(require("@babel/plugin-proposal-logical-assignment-operators"));

var proposalPrivateMethods = _interopRequireWildcard(require("@babel/plugin-proposal-private-methods"));

var proposalAsyncGeneratorFunctions = _interopRequireWildcard(require("@babel/plugin-proposal-async-generator-functions"));

var proposalFunctionSent = _interopRequireWildcard(require("@babel/plugin-proposal-function-sent"));

var proposalDoExpressions = _interopRequireWildcard(require("@babel/plugin-proposal-do-expressions"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var jsMeta = {
  actions: [],
  imports: [],
  tagNames: [],
  functions: [],
  computeds: [],
  props: [],
  unknownProps: [],
  attributeBindings: [],
  positionalParams: [],
  concatenatedProperties: [],
  mergedProperties: [],
  classNameBindings: [],
  classNames: [],
  exports: []
};

function extractActions(path) {
  return path.node.value.properties.map(function (node) {
    var params = node.params.map(function (p) {
      return p.name;
    });
    return "".concat(node.key.name, "(").concat(params.join(", "), ")");
  });
}

function extractClassNames(path) {
  return path.node.value.elements.map(function (el) {
    return el.value;
  });
}

function looksLikeReexport(path) {
  if (path.node.body.length === 2 && path.node.sourceType === "module") {
    var childs = path.node.body;

    if (childs[0].type === "ImportDeclaration" && childs[1].type === "ExportDefaultDeclaration") {
      return true;
    }
  }

  return false;
}

function propExtractor(path) {
  var name = path.node.key.name;

  if (path.node.value === null) {
    var value = '';

    if (path.node.typeAnnotation && path.node.typeAnnotation.typeAnnotation) {
      var annotation = path.node.typeAnnotation.typeAnnotation; // TSAnyKeyword

      if (annotation.type === 'TSAnyKeyword') {
        value = 'any';
      } else if (annotation.typeName) {
        value = annotation.typeName.name || '';
      }
    }

    if (value !== '') {
      jsMeta.props.push("".concat(name, " = <").concat(value, ">"));
    } else {
      jsMeta.props.push("".concat(name, " = undefined"));
    }

    return;
  }

  var valueType = path.node.value.type;
  var valueElements = path.node.value.elements || [];

  if (name === "actions") {
    if (!jsMeta.actions) {
      jsMeta.actions = [];
    }

    jsMeta.actions = jsMeta.actions.concat(extractActions(path));
  } else if (name === "classNames") {
    jsMeta.classNames = extractClassNames(path);
  } else if (name === "tagName" && valueType === "StringLiteral") {
    jsMeta.tagNames = [path.node.value.value];
  } else if (name === "attributeBindings") {
    valueElements.map(function (el) {
      return el.value;
    }).forEach(function (value) {
      jsMeta.unknownProps.push(value.split(":")[0]);
    });
    jsMeta.attributeBindings = valueElements.map(function (el) {
      return el.value;
    });
  } else if (name === "classNameBindings") {
    valueElements.map(function (el) {
      return el.value;
    }).forEach(function (value) {
      jsMeta.unknownProps.push(value.split(":")[0]);
    });
    jsMeta.classNameBindings = valueElements.map(function (el) {
      return el.value;
    });
  } else if (name === "concatenatedProperties") {
    jsMeta.concatenatedProperties = valueElements.map(function (el) {
      return el.value;
    });
  } else if (name === "mergedProperties") {
    jsMeta.mergedProperties = valueElements.map(function (el) {
      return el.value;
    });
  } else if (name === "positionalParams") {
    jsMeta.positionalParams = valueElements.map(function (el) {
      return el.value;
    });
  } else if (valueType === "CallExpression") {
    var cname = path.node.value.callee.name;

    if (cname === "service") {
      jsMeta.computeds.push(name + ' = service("' + (path.node.value.arguments.length ? path.node.value.arguments[0].value : name) + '")');
      return;
    }

    var postfix = "";
    var ar = [];

    if (path.node.value.callee.type === "MemberExpression") {
      cname = path.node.value.callee.object.callee ? path.node.value.callee.object.callee.name : "<UNKNOWN>";
      postfix = path.node.value.callee.property.name + "()";
      path.node.value.callee.object.arguments.forEach(function (arg) {
        if (arg.type === "StringLiteral") {
          jsMeta.unknownProps.push(arg.value);
          ar.push("'".concat(arg.value, "'"));
        }
      });
    }

    path.node.value.arguments.forEach(function (arg) {
      if (arg.type === "StringLiteral") {
        jsMeta.unknownProps.push(arg.value);
        ar.push("'".concat(arg.value, "'"));
      }
    });

    if (path.node.value.arguments.length) {
      var isLastArgFn = path.node.value.arguments[path.node.value.arguments.length - 1].type === "FunctionExpression";

      if (isLastArgFn) {
        ar.push("fn() {...}");
      }
    } // path.node.value.arguments


    jsMeta.computeds.push(name + " = " + cname + "(" + ar.join(", ") + ")" + (postfix ? "." + postfix : ""));
  } else if (valueType === "NumericLiteral") {
    jsMeta.props.push("".concat(name, " = ").concat(path.node.value.value));
  } else if (valueType === "StringLiteral") {
    jsMeta.props.push("".concat(name, " = \"").concat(path.node.value.value, "\""));
  } else if (valueType === "BooleanLiteral") {
    jsMeta.props.push("".concat(name, " = ").concat(path.node.value.value));
  } else if (valueType === "NullLiteral") {
    jsMeta.props.push("".concat(name, " = null "));
  } else if (valueType === "ObjectExpression") {
    jsMeta.props.push("".concat(name, " = { ... } "));
  } else if (valueType === "ArrayExpression") {
    jsMeta.props.push("".concat(name, " = [ ... ] "));
  } else if (valueType === "Identifier") {
    jsMeta.props.push("".concat(name, " = ").concat(path.node.value.name, " "));
  } else if (valueType === "ArrowFunctionExpression") {
    jsMeta.props.push("".concat(name, " = () => {} "));
  } else if (valueType === "ConditionalExpression") {
    jsMeta.props.push("".concat(name, " = X ? Y : Z "));
  } else if (valueType === "TaggedTemplateExpression") {
    jsMeta.props.push("".concat(name, " = ").concat(path.node.value.tag.name, "`...` "));
  }
}

var componentAnalyzer = function componentAnalyzer() {
  // console.log(Object.keys(babel.file));
  return {
    ClassDeclaration: function ClassDeclaration(path) {
      if (path.node.superClass && path.node.superClass.type === "CallExpression") {
        //   const calleeName = path.node.superClass.callee.property.name;
        //   if (!['extend', 'reopen','reopenClass'].includes(calleeName)) {
        // 	return;
        //   }
        (path.node.superClass.arguments || []).forEach(function (arg) {
          if (arg.type === "ObjectExpression") {
            (arg.properties || []).forEach(function (a) {
              if (a.type === "ObjectProperty") {
                a.__IS_VALID_EMBER_COMPOENENT_OBJECT_PROPERTY = true;
              }
            });
          }
        });
      }
    },
    ClassProperty: function ClassProperty(path) {
      propExtractor(path);
    },
    Program: function Program(path) {
      if (looksLikeReexport(path)) {
        jsMeta.exports.push(path.node.body[0].source.value);
      }
    },
    ExportNamedDeclaration: function ExportNamedDeclaration(path) {
      if (!path.node.source) {
        return;
      }

      var source = path.node.source.value;
      jsMeta.exports.push(source);
    },
    ImportDeclaration: function ImportDeclaration(path) {
      if (!path.node.source) {
        return;
      }

      var source = path.node.source.value;
      jsMeta.imports.push(source);
    },
    ObjectExpression: function ObjectExpression(path) {
      var methods = path.node.properties.filter(function (prop) {
        return prop.type === "ObjectMethod";
      });
      methods.forEach(function (method) {
        var params = method.params.map(function (p) {
          return p.name;
        });
        jsMeta.functions.push("".concat(method.key.name, "(").concat(params.join(", "), ")"));
      });
    },
    ClassMethod: function ClassMethod(path) {
      if (path.parent.type !== 'ClassBody') {
        return;
      }

      if (path.node.kind === 'method') {
        var params = path.node.params.map(function (p) {
          return p.name;
        });
        var hasActionDecorator = false;

        if (path.node.decorators && path.node.decorators.length) {
          path.node.decorators.forEach(function (dec) {
            if (dec.expression.name === 'action') {
              hasActionDecorator = true;
            }
          });
        }

        if (hasActionDecorator) {
          if (!jsMeta.actions) {
            jsMeta.actions = [];
          }

          jsMeta.actions.push("".concat(path.node.key.name, "(").concat(params.join(", "), ")"));
        } else {
          jsMeta.functions.push("".concat(path.node.key.name, "(").concat(params.join(", "), ")"));
        }
      } else if (path.node.kind === 'get') {
        jsMeta.computeds.push("".concat(path.node.key.name, " = get fn()"));
      }
    },
    ObjectProperty: function ObjectProperty(path) {
      var isValidParent = !path.scope.parent || path.node.__IS_VALID_EMBER_COMPOENENT_OBJECT_PROPERTY;

      if (path.parent.type === "ObjectExpression" && isValidParent) {
        propExtractor(path);
      }
    }
  };
};

function resetJSMeta() {
  jsMeta = {
    actions: [],
    imports: [],
    tagNames: [],
    functions: [],
    computeds: [],
    props: [],
    unknownProps: [],
    attributeBindings: [],
    positionalParams: [],
    concatenatedProperties: [],
    mergedProperties: [],
    classNameBindings: [],
    classNames: [],
    exports: []
  };
}

var babelOptions = {
  presets: [presetTypeScript],
  plugins: [[proposalDecorators, {
    legacy: true
  }], [proposalClassProperties, {
    loose: true
  }], proposalObjectRestSpread, proposalOptionalChaining, proposalNullishCoalescingOperator, proposalNumericSeparator, proposalLogicalAssignmentOperators, proposalPrivateMethods, proposalAsyncGeneratorFunctions, proposalFunctionSent, proposalDoExpressions],
  sourceType: "module",
  // parserOpts: {
  // 	'tsConfig': '12'
  // },
  babelrc: false,
  configFile: false,
  cwd: __dirname,
  filename: Math.random() + "-.ts"
};

function parseScriptFile(data, secondaryBabelOptions) {
  return (0, _core.parseSync)(data, Object.assign({}, babelOptions, secondaryBabelOptions));
}

function processJSFile(data, relativePath) {
  resetJSMeta();
  var ast = (0, _core.parseSync)(data, babelOptions);
  (0, _traverse["default"])(ast, componentAnalyzer());
  var meta = jsMeta; //   meta.code = result.code;

  meta.imports = meta.imports.map(function (imp) {
    var paths = relativePath.split(_path.sep);
    var base = imp.split("/")[0];
    paths.pop();

    if (imp.startsWith(".")) {
      var maybeFile = (0, _path.join)(paths.join(_path.sep), (0, _fileUtils.normalizePath)(imp));
      var jsPath = maybeFile + ".js";
      var hbsPath = maybeFile + ".hbs";

      if ((0, _fs.existsSync)(jsPath)) {
        return (0, _fileUtils.serializePath)(jsPath);
      } else if ((0, _fs.existsSync)(hbsPath)) {
        return (0, _fileUtils.serializePath)(hbsPath);
      } else {
        return (0, _fileUtils.serializePath)(maybeFile);
      }
    } else {
      if (imp.includes("/templates/components/")) {
        var pureImp = imp.replace(base, "");

        var _serializePath$split = (0, _fileUtils.serializePath)(relativePath).split(base),
            _serializePath$split2 = _slicedToArray(_serializePath$split, 1),
            root = _serializePath$split2[0];

        var posiblePaths = [];
        posiblePaths.push(root + base + "/addon" + pureImp + ".js");
        posiblePaths.push(root + base + "/addon" + pureImp + ".hbs");
        posiblePaths.push(root + base + "/app" + pureImp + ".js");
        posiblePaths.push(root + base + "/app" + pureImp + ".hbs");
        var result = imp;
        posiblePaths.forEach(function (p) {
          if ((0, _fs.existsSync)((0, _fileUtils.normalizePath)(p))) {
            result = (0, _fileUtils.serializePath)(p);
          }
        });
        return result;
      } else if (imp.includes("/mixins/")) {
        var _pureImp = imp.replace(base, "");

        var _serializePath$split3 = (0, _fileUtils.serializePath)(relativePath).split(base),
            _serializePath$split4 = _slicedToArray(_serializePath$split3, 1),
            _root = _serializePath$split4[0];

        var _posiblePaths = [];

        _posiblePaths.push(_root + base + "/addon" + _pureImp + ".js");

        var _result = imp;

        _posiblePaths.forEach(function (p) {
          if ((0, _fs.existsSync)((0, _fileUtils.normalizePath)(p))) {
            _result = (0, _fileUtils.serializePath)(p);
          }
        });

        return _result;
      }

      return imp;
    }
  });
  meta.exports = meta.exports.map(function (imp) {
    if (imp.startsWith(".")) {
      var paths = relativePath.split(_path.sep);
      paths.pop();
      var maybeFile = (0, _path.join)(paths.join(_path.sep), (0, _fileUtils.normalizePath)(imp));
      var jsPath = maybeFile + ".js";
      var hbsPath = maybeFile + ".hbs";

      if ((0, _fs.existsSync)(jsPath)) {
        return (0, _fileUtils.serializePath)(jsPath);
      } else if ((0, _fs.existsSync)(hbsPath)) {
        return (0, _fileUtils.serializePath)(hbsPath);
      } else {
        return (0, _fileUtils.serializePath)(maybeFile);
      }
    } else {
      return imp;
    }
  });
  return meta;
}