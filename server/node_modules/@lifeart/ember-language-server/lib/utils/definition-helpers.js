"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAddonPathsForType = exports.getAddonImport = exports.getPathsForComponentTemplates = exports.getPathsForComponentScripts = exports.getAbstractComponentTemplatesParts = exports.getAbstractComponentScriptsParts = exports.getAbstractPartsWithTemplates = exports.getAbstractParts = exports.pathsToLocationsWithPosition = exports.importPathsToLocations = exports.getFirstTextPostion = exports.pathsToLocations = void 0;
const path = require("path");
const memoize = require("memoizee");
const node_1 = require("vscode-languageserver/node");
const vscode_uri_1 = require("vscode-uri");
const layout_helpers_1 = require("./layout-helpers");
const fs_provider_1 = require("../fs-provider");
const mProjectAddonsRoots = memoize(layout_helpers_1.getProjectAddonsRoots, {
    length: 3,
    maxAge: 600000,
});
const mProjectInRepoAddonsRoots = memoize(layout_helpers_1.getProjectInRepoAddonsRoots, {
    length: 1,
    maxAge: 600000,
});
function pathsToLocations(...paths) {
    return paths.map((modulePath) => {
        return node_1.Location.create(vscode_uri_1.URI.file(modulePath).toString(), node_1.Range.create(0, 0, 0, 0));
    });
}
exports.pathsToLocations = pathsToLocations;
function getFirstTextPostion(text, content) {
    const arrayOfLines = text.match(/(.*?(?:\r\n?|\n|$))/gm) || [];
    let startLine = 0;
    let startCharacter = 0;
    arrayOfLines.forEach((line, index) => {
        if (startLine || startCharacter) {
            return;
        }
        const textPosition = line.indexOf(content);
        const bounds = line.split(content);
        if (textPosition > -1) {
            if (/\s/.test(bounds[0].charAt(bounds[0].length - 1)) || bounds[0].trim().length === 0) {
                if (/^[A-Za-z]+$/.test(bounds[1].charAt(0)) === false) {
                    startLine = index;
                    startCharacter = textPosition;
                }
            }
        }
    });
    return [startLine, startCharacter];
}
exports.getFirstTextPostion = getFirstTextPostion;
async function importPathsToLocations(paths, importName) {
    if (importName) {
        const locations = paths.map(async (modulePath) => {
            const file = await (0, fs_provider_1.fsProvider)().readFile(modulePath);
            if (file === null) {
                return null;
            }
            const arr = file.split(/\r?\n/).map((l) => l.trim());
            const idxFound = arr.findIndex((line) => line.includes(importName) && line.startsWith('export '));
            const useIndex = idxFound > -1 ? idxFound : 0;
            const start = idxFound > -1 ? arr[idxFound].indexOf(importName) : 0;
            const end = idxFound > -1 ? start + importName.length : 0;
            return node_1.Location.create(vscode_uri_1.URI.file(modulePath).toString(), node_1.Range.create(useIndex, start, useIndex, end));
        });
        const results = await Promise.all(locations);
        return results.filter((r) => r !== null);
    }
    return Promise.resolve(pathsToLocations(...paths));
}
exports.importPathsToLocations = importPathsToLocations;
async function pathsToLocationsWithPosition(paths, findMe) {
    const results = paths.map(async (fileName) => {
        const text = await (0, fs_provider_1.fsProvider)().readFile(fileName);
        if (text === null) {
            return null;
        }
        const [startLine, startCharacter] = getFirstTextPostion(text, findMe);
        return node_1.Location.create(vscode_uri_1.URI.file(fileName).toString(), node_1.Range.create(startLine, startCharacter, startLine, startCharacter + findMe.length));
    });
    const data = await Promise.all(results);
    return data.filter((el) => el !== null);
}
exports.pathsToLocationsWithPosition = pathsToLocationsWithPosition;
function getAbstractParts(root, prefix, collection, name) {
    return [
        [root, prefix, collection, `${name}.js`],
        [root, prefix, collection, `${name}.ts`],
    ];
}
exports.getAbstractParts = getAbstractParts;
function getAbstractPartsWithTemplates(root, prefix, collection) {
    const importParts = [...collection];
    const name = importParts.pop();
    return [
        [root, prefix, ...importParts, `${name}.js`],
        [root, prefix, ...importParts, `${name}.ts`],
        [root, prefix, ...importParts, `${name}.hbs`],
    ];
}
exports.getAbstractPartsWithTemplates = getAbstractPartsWithTemplates;
function getAbstractComponentScriptsParts(root, prefix, maybeComponentName) {
    return [
        [root, prefix, 'components', maybeComponentName + '.js'],
        [root, prefix, 'components', maybeComponentName + '.ts'],
        [root, prefix, 'components', maybeComponentName, 'component.js'],
        [root, prefix, 'components', maybeComponentName, 'component.ts'],
        [root, prefix, 'components', maybeComponentName, 'index.js'],
        [root, prefix, 'components', maybeComponentName, 'index.ts'],
    ];
}
exports.getAbstractComponentScriptsParts = getAbstractComponentScriptsParts;
function getAbstractComponentTemplatesParts(root, prefix, maybeComponentName) {
    return [
        [root, prefix, 'components', maybeComponentName, 'template.hbs'],
        [root, prefix, 'components', maybeComponentName, 'index.hbs'],
        [root, prefix, 'components', maybeComponentName + '.hbs'],
        [root, prefix, 'templates', 'components', maybeComponentName + '.hbs'],
    ];
}
exports.getAbstractComponentTemplatesParts = getAbstractComponentTemplatesParts;
function getPathsForComponentScripts(root, maybeComponentName) {
    const podModulePrefix = (0, layout_helpers_1.podModulePrefixForRoot)(root);
    let podComponentsScriptsParts = [];
    let classicComponentsScriptsParts = [];
    if (podModulePrefix) {
        podComponentsScriptsParts = getAbstractComponentScriptsParts(root, 'app/' + podModulePrefix, maybeComponentName);
    }
    classicComponentsScriptsParts = getAbstractComponentScriptsParts(root, 'app', maybeComponentName);
    const paths = [...podComponentsScriptsParts, ...classicComponentsScriptsParts].map((pathParts) => {
        return path.join(...pathParts.filter((part) => !!part));
    });
    return paths;
}
exports.getPathsForComponentScripts = getPathsForComponentScripts;
function getPathsForComponentTemplates(root, maybeComponentName) {
    const podModulePrefix = (0, layout_helpers_1.podModulePrefixForRoot)(root);
    let podComponentsScriptsParts = [];
    let classicComponentsScriptsParts = [];
    if (podModulePrefix) {
        podComponentsScriptsParts = getAbstractComponentTemplatesParts(root, 'app' + path.sep + podModulePrefix, maybeComponentName);
    }
    classicComponentsScriptsParts = getAbstractComponentTemplatesParts(root, 'app', maybeComponentName);
    const paths = [...podComponentsScriptsParts, ...classicComponentsScriptsParts].map((pathParts) => {
        return path.join(...pathParts.filter((part) => !!part));
    });
    return paths;
}
exports.getPathsForComponentTemplates = getPathsForComponentTemplates;
async function getAddonImport(root, importPath) {
    const importParts = importPath.split('/');
    let addonName = importParts.shift();
    if (addonName && addonName.startsWith('@')) {
        addonName = addonName + path.sep + importParts.shift();
    }
    if (!addonName) {
        return [];
    }
    const items = [];
    const [addonRoots, inRepoRoots] = await Promise.all([mProjectAddonsRoots(root), mProjectInRepoAddonsRoots(root)]);
    const roots = items.concat(addonRoots, inRepoRoots);
    let existingPaths = [];
    let hasValidPath = false;
    for (const rootPath of roots) {
        if (!rootPath.endsWith(addonName)) {
            continue;
        }
        if (hasValidPath) {
            continue;
        }
        const addonPaths = [];
        const possibleLocations = [
            [rootPath, 'app', importParts],
            [rootPath, 'addon', importParts],
            [rootPath, '', importParts],
        ];
        possibleLocations.forEach((locationArr) => {
            getAbstractPartsWithTemplates(...locationArr).forEach((parts) => {
                addonPaths.push(parts);
            });
        });
        const rawPaths = addonPaths.map((pathArr) => {
            return path.join(...pathArr.filter((part) => !!part));
        });
        const validPaths = await (0, layout_helpers_1.asyncFilter)(rawPaths, (0, fs_provider_1.fsProvider)().exists);
        if (validPaths.length) {
            hasValidPath = true;
            existingPaths = validPaths;
        }
    }
    const addonFolderFiles = existingPaths.filter(layout_helpers_1.hasAddonFolderInPath);
    if (addonFolderFiles.length) {
        return addonFolderFiles;
    }
    return existingPaths;
}
exports.getAddonImport = getAddonImport;
async function getAddonPathsForType(root, collection, name) {
    const items = [];
    const [addonRoots, inRepoRoots] = await Promise.all([mProjectAddonsRoots(root), mProjectInRepoAddonsRoots(root)]);
    const roots = items.concat(addonRoots, inRepoRoots);
    let existingPaths = [];
    let hasValidPath = false;
    for (const rootPath of roots) {
        if (hasValidPath) {
            break;
        }
        const addonPaths = [];
        getAbstractParts(rootPath, 'app', collection, name).forEach((parts) => {
            addonPaths.push(parts);
        });
        getAbstractParts(rootPath, 'addon', collection, name).forEach((parts) => {
            addonPaths.push(parts);
        });
        const rawPaths = addonPaths.map((pathArr) => {
            return path.join(...pathArr.filter((part) => !!part));
        });
        const validPaths = await (0, layout_helpers_1.asyncFilter)(rawPaths, (0, fs_provider_1.fsProvider)().exists);
        if (validPaths.length) {
            hasValidPath = true;
            existingPaths = validPaths;
        }
    }
    const addonFolderFiles = existingPaths.filter(layout_helpers_1.hasAddonFolderInPath);
    if (addonFolderFiles.length) {
        return addonFolderFiles;
    }
    return existingPaths;
}
exports.getAddonPathsForType = getAddonPathsForType;
//# sourceMappingURL=definition-helpers.js.map