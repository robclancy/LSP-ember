"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDebugModeEnabled = exports.languageServerHandler = exports.extensionCapabilities = exports.emptyProjectProviders = exports.collectProjectProviders = exports.isConstructor = exports.queryELSAddonsAPIChain = void 0;
const layout_helpers_1 = require("./layout-helpers");
const path = require("path");
const logger_1 = require("./logger");
const dag_map_1 = require("dag-map");
async function queryELSAddonsAPIChain(callbacks, root, params) {
    let lastResult = params.results || [];
    for (const callback of callbacks) {
        try {
            const tempResult = await callback(root, Object.assign({}, params, { results: JSON.parse((0, logger_1.safeStringify)(lastResult)) }));
            // API must return array
            if (Array.isArray(tempResult)) {
                lastResult = tempResult;
            }
        }
        catch (e) {
            (0, logger_1.logError)(e);
            (0, logger_1.log)('ELSAddonsAPIError', callback, e.toString(), root, params);
        }
    }
    return lastResult;
}
exports.queryELSAddonsAPIChain = queryELSAddonsAPIChain;
function isConstructor(obj) {
    return !!obj.prototype && !!obj.prototype.constructor.name;
}
exports.isConstructor = isConstructor;
function create(model) {
    return new model();
}
let requireFunc = {
    resolve(a) {
        return a;
    },
};
try {
    requireFunc =
        // @ts-expect-error @todo - fix webpack imports
        typeof __webpack_require__ === 'function'
            ? // @ts-expect-error @todo - fix webpack imports
                __non_webpack_require__
            : typeof require !== 'undefined'
                ? require
                : function () {
                    // EOL
                };
}
catch (e) {
    // expected error in worker
}
function requireUncached(module) {
    if (!(0, layout_helpers_1.getRequireSupport)()) {
        return {
            onInit() {
                throw new Error('Unable to use require in worker environment');
            },
        };
    }
    delete require.cache[requireFunc.resolve(module)];
    let result = {};
    try {
        result = requireFunc(module);
        if (isConstructor(result)) {
            const instance = create(result);
            const instanceResult = {};
            if (typeof instance.onInit === 'function') {
                instanceResult.onInit = instance.onInit.bind(instance);
            }
            if (typeof instance.onCodeAction === 'function') {
                instanceResult.onCodeAction = instance.onCodeAction.bind(instance);
            }
            if (typeof instance.onComplete === 'function') {
                instanceResult.onComplete = instance.onComplete.bind(instance);
            }
            if (typeof instance.onDefinition === 'function') {
                instanceResult.onDefinition = instance.onDefinition.bind(instance);
            }
            if (typeof instance.onReference === 'function') {
                instanceResult.onReference = instance.onReference.bind(instance);
            }
            if (typeof instance.onHover === 'function') {
                instanceResult.onHover = instance.onHover.bind(instance);
            }
            return instanceResult;
        }
    }
    catch (e) {
        (0, logger_1.logError)(e);
        return {
            onInit() {
                const err = e.toString();
                throw new Error('Unable to require els-addon by path: ' + module + ', reason: ' + err);
            },
        };
    }
    return result;
}
async function collectProjectProviders(root, addons) {
    const [projectAddonsRoots, projectInRepoAddonsRoots] = await Promise.all([(0, layout_helpers_1.getProjectAddonsRoots)(root), (0, layout_helpers_1.getProjectInRepoAddonsRoots)(root)]);
    const roots = addons
        .concat([root])
        .concat(projectAddonsRoots, projectInRepoAddonsRoots)
        .filter((pathItem) => typeof pathItem === 'string');
    const dagMap = new dag_map_1.default();
    const addonsMeta = [];
    for (const packagePath of roots) {
        const info = await (0, layout_helpers_1.asyncGetPackageJSON)(packagePath);
        if (info.name) {
            addonsMeta.push({
                name: info.name,
                root: packagePath,
                version: (0, layout_helpers_1.addonVersion)(info),
            });
        }
        if ((0, layout_helpers_1.hasEmberLanguageServerExtension)(info)) {
            const handlerPath = languageServerHandler(info);
            const addonInfo = info['ember-addon'] || {};
            const addon = {
                handler: requireUncached(path.join(packagePath, handlerPath)),
                updateHandler() {
                    this.handler = requireUncached(path.join(packagePath, handlerPath));
                },
                packageRoot: packagePath,
                packageJSON: info,
                debug: isDebugModeEnabled(info),
                capabilities: normalizeCapabilities(extensionCapabilities(info)),
            };
            dagMap.add(info.name || packagePath, addon, addonInfo.before, addonInfo.after);
        }
    }
    const result = emptyProjectProviders({
        addonsMeta,
    });
    // onReference, onComplete, onDefinition
    dagMap.each((_, handlerObject) => {
        if (handlerObject === undefined) {
            return;
        }
        // let's reload files in case of debug mode for each request
        if (handlerObject.debug) {
            result.info.push('addon-in-debug-mode: ' + _);
            (0, logger_1.logInfo)(`els-addon-api: debug mode enabled for ${handlerObject.packageRoot}, for all requests resolvers will be reloaded.`);
            result.completionProviders.push(function (root, params) {
                handlerObject.updateHandler();
                if (typeof handlerObject.handler.onComplete === 'function') {
                    return handlerObject.handler.onComplete(root, params);
                }
                else {
                    return params.results;
                }
            });
            result.referencesProviders.push(function (root, params) {
                handlerObject.updateHandler();
                if (typeof handlerObject.handler.onReference === 'function') {
                    return handlerObject.handler.onReference(root, params);
                }
                else {
                    return params.results;
                }
            });
            result.hoverProviders.push(function (root, params) {
                handlerObject.updateHandler();
                if (typeof handlerObject.handler.onHover === 'function') {
                    return handlerObject.handler.onHover(root, params);
                }
                else {
                    return params.results;
                }
            });
            result.definitionProviders.push(function (root, params) {
                handlerObject.updateHandler();
                if (typeof handlerObject.handler.onDefinition === 'function') {
                    return handlerObject.handler.onDefinition(root, params);
                }
                else {
                    return params.results;
                }
            });
            result.initFunctions.push(function (server, project) {
                handlerObject.updateHandler();
                if (typeof handlerObject.handler.onInit === 'function') {
                    return handlerObject.handler.onInit(server, project);
                }
                else {
                    return;
                }
            });
            result.codeActionProviders.push(function (root, params) {
                handlerObject.updateHandler();
                if (typeof handlerObject.handler.onCodeAction === 'function') {
                    return handlerObject.handler.onCodeAction(root, params);
                }
                else {
                    return;
                }
            });
        }
        else {
            result.info.push('addon: ' + _);
            if (handlerObject.capabilities.completionProvider && typeof handlerObject.handler.onComplete === 'function') {
                result.completionProviders.push(handlerObject.handler.onComplete);
            }
            if (handlerObject.capabilities.referencesProvider && typeof handlerObject.handler.onReference === 'function') {
                result.referencesProviders.push(handlerObject.handler.onReference);
            }
            if (handlerObject.capabilities.hoverProvider && typeof handlerObject.handler.onHover === 'function') {
                result.hoverProviders.push(handlerObject.handler.onHover);
            }
            if (handlerObject.capabilities.definitionProvider && typeof handlerObject.handler.onDefinition === 'function') {
                result.definitionProviders.push(handlerObject.handler.onDefinition);
            }
            if (handlerObject.capabilities.codeActionProvider && typeof handlerObject.handler.onCodeAction === 'function') {
                result.codeActionProviders.push(handlerObject.handler.onCodeAction);
            }
            if (typeof handlerObject.handler.onInit === 'function') {
                result.initFunctions.push(handlerObject.handler.onInit);
            }
        }
    });
    return result;
}
exports.collectProjectProviders = collectProjectProviders;
function emptyProjectProviders(providers) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return {
        definitionProviders: (_a = providers === null || providers === void 0 ? void 0 : providers.definitionProviders) !== null && _a !== void 0 ? _a : [],
        hoverProviders: (_b = providers === null || providers === void 0 ? void 0 : providers.hoverProviders) !== null && _b !== void 0 ? _b : [],
        referencesProviders: (_c = providers === null || providers === void 0 ? void 0 : providers.referencesProviders) !== null && _c !== void 0 ? _c : [],
        completionProviders: (_d = providers === null || providers === void 0 ? void 0 : providers.completionProviders) !== null && _d !== void 0 ? _d : [],
        codeActionProviders: (_e = providers === null || providers === void 0 ? void 0 : providers.codeActionProviders) !== null && _e !== void 0 ? _e : [],
        initFunctions: (_f = providers === null || providers === void 0 ? void 0 : providers.initFunctions) !== null && _f !== void 0 ? _f : [],
        info: (_g = providers === null || providers === void 0 ? void 0 : providers.info) !== null && _g !== void 0 ? _g : [],
        addonsMeta: (_h = providers === null || providers === void 0 ? void 0 : providers.addonsMeta) !== null && _h !== void 0 ? _h : [],
    };
}
exports.emptyProjectProviders = emptyProjectProviders;
function normalizeCapabilities(raw) {
    return {
        hoverProvider: raw.hoverProvider === true,
        definitionProvider: raw.definitionProvider === true,
        codeActionProvider: raw.codeActionProvider === true,
        referencesProvider: raw.referencesProvider === true || (typeof raw.referencesProvider === 'object' && raw.referencesProvider.components === true),
        completionProvider: typeof raw.completionProvider === 'object' || raw.completionProvider === true,
    };
}
function extensionCapabilities(info) {
    return info[layout_helpers_1.ADDON_CONFIG_KEY].capabilities || {};
}
exports.extensionCapabilities = extensionCapabilities;
function languageServerHandler(info) {
    return info[layout_helpers_1.ADDON_CONFIG_KEY].entry;
}
exports.languageServerHandler = languageServerHandler;
function isDebugModeEnabled(info) {
    return info[layout_helpers_1.ADDON_CONFIG_KEY].debug === true;
}
exports.isDebugModeEnabled = isDebugModeEnabled;
//# sourceMappingURL=addon-api.js.map