"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const definition_helpers_1 = require("../../utils/definition-helpers");
const ast_helpers_1 = require("./../../utils/ast-helpers");
const normalizers_1 = require("../../utils/normalizers");
const layout_helpers_1 = require("./../../utils/layout-helpers");
const template_definition_provider_1 = require("./template-definition-provider");
const logger_1 = require("../../utils/logger");
function joinPaths(...args) {
    return ['.ts', '.js'].map((extName) => {
        const localArgs = args.slice(0);
        const lastArg = localArgs.pop() + extName;
        return path.join.apply(path, [...localArgs, lastArg]);
    });
}
class PathResolvers {
    muModelPaths(root, modelName) {
        return joinPaths(root, 'src', 'data', 'models', modelName, 'model');
    }
    muTransformPaths(root, transformName) {
        return joinPaths(root, 'src', 'data', 'transforms', transformName);
    }
    muServicePaths(root, transformName) {
        return joinPaths(root, 'src', 'services', transformName);
    }
    classicModelPaths(root, modelName) {
        return joinPaths(root, 'app', 'models', modelName);
    }
    classicTransformPaths(root, transformName) {
        return joinPaths(root, 'app', 'transforms', transformName);
    }
    classicServicePaths(root, modelName) {
        return joinPaths(root, 'app', 'services', modelName);
    }
    podTransformPaths(root, transformName, podPrefix) {
        return joinPaths(root, 'app', podPrefix, transformName, 'transform');
    }
    podModelPaths(root, modelName, podPrefix) {
        return joinPaths(root, 'app', podPrefix, modelName, 'model');
    }
    podServicePaths(root, modelName, podPrefix) {
        return joinPaths(root, 'app', podPrefix, modelName, 'service');
    }
    async addonServicePaths(root, serviceName) {
        return await (0, definition_helpers_1.getAddonPathsForType)(root, 'services', serviceName);
    }
    async addonImportPaths(root, pathName) {
        return await (0, definition_helpers_1.getAddonImport)(root, pathName);
    }
    classicImportPaths(root, pathName) {
        const pathParts = pathName.split('/');
        pathParts.shift();
        const appParams = [root, 'app', ...pathParts];
        return joinPaths(...appParams);
    }
    resolveTestScopeImport(root, pathName) {
        return joinPaths(path.join(root, pathName));
    }
    muImportPaths(root, pathName) {
        const pathParts = pathName.split('/');
        pathParts.shift();
        const params = [root, ...pathParts];
        return joinPaths(...params);
    }
}
class CoreScriptDefinitionProvider {
    constructor() {
        this.resolvers = new PathResolvers();
    }
    get registry() {
        return this.project.registry;
    }
    async onInit(server, project) {
        this.server = server;
        this.project = project;
    }
    async guessPathForImport(root, uri, importPath, importName = '') {
        if (!uri) {
            return null;
        }
        const guessedPaths = [];
        const fnName = 'Import';
        (await this.resolvers[`classic${fnName}Paths`](root, importPath)).forEach((pathLocation) => {
            guessedPaths.push(pathLocation);
        });
        const addonImports = await this.resolvers.addonImportPaths(root, importPath);
        addonImports.forEach((pathLocation) => {
            guessedPaths.push(pathLocation);
        });
        const existingPaths = await (0, layout_helpers_1.asyncFilter)(guessedPaths, this.server.fs.exists);
        return (0, definition_helpers_1.importPathsToLocations)(existingPaths, importName);
    }
    async guessPathsForType(root, fnName, typeName) {
        const guessedPaths = [];
        (await this.resolvers[`classic${fnName}Paths`](root, typeName)).forEach((pathLocation) => {
            guessedPaths.push(pathLocation);
        });
        const podPrefix = (0, layout_helpers_1.podModulePrefixForRoot)(root);
        if (podPrefix) {
            (await this.resolvers[`pod${fnName}Paths`](root, typeName, podPrefix)).forEach((pathLocation) => {
                guessedPaths.push(pathLocation);
            });
        }
        if (fnName === 'Service') {
            const paths = await this.resolvers.addonServicePaths(root, typeName);
            paths.forEach((item) => {
                guessedPaths.push(item);
            });
        }
        const existingPaths = await (0, layout_helpers_1.asyncFilter)(guessedPaths, this.server.fs.exists);
        return (0, definition_helpers_1.pathsToLocations)(...existingPaths);
    }
    getImportSpecifierName(importDeclaration, position) {
        const importNameData = importDeclaration.specifiers.find((item) => {
            var _a, _b, _c;
            const importLine = (_a = item.loc) === null || _a === void 0 ? void 0 : _a.start.line;
            const importStartCol = (_b = item.loc) === null || _b === void 0 ? void 0 : _b.start.column;
            const importStartEnd = (_c = item.loc) === null || _c === void 0 ? void 0 : _c.end.column;
            return (importStartCol && importStartEnd && position.line + 1 === importLine && importStartCol <= position.character && importStartEnd >= position.character);
        });
        return importNameData && importNameData.type === 'ImportSpecifier' ? importNameData.imported.name : '';
    }
    async onDefinition(root, params) {
        const { textDocument, focusPath, type, results, server, position } = params;
        if (type !== 'script') {
            return results;
        }
        const uri = textDocument.uri;
        let definitions = results;
        const astPath = focusPath;
        const project = server.projectRoots.projectForUri(uri);
        if (!project) {
            return results;
        }
        if ((0, ast_helpers_1.isTemplateElement)(astPath)) {
            const templateResults = await server.definitionProvider.template.handle({
                textDocument,
                position,
            }, project);
            if (Array.isArray(templateResults)) {
                definitions = templateResults;
            }
        }
        else if ((0, ast_helpers_1.isModelReference)(astPath)) {
            const modelName = astPath.node.value;
            definitions = await this.guessPathsForType(root, 'Model', modelName);
        }
        else if ((0, ast_helpers_1.isTransformReference)(astPath)) {
            const transformName = astPath.node.value;
            definitions = await this.guessPathsForType(root, 'Transform', transformName);
        }
        else if ((0, ast_helpers_1.isImportPathDeclaration)(astPath)) {
            definitions = (await this.guessPathForImport(root, uri, astPath.node.value)) || [];
        }
        else if ((0, ast_helpers_1.isImportSpecifier)(astPath) || (0, ast_helpers_1.isImportDefaultSpecifier)(astPath)) {
            (0, logger_1.logInfo)(`Handle script import for Project "${project.name}"`);
            const importDeclaration = astPath.parentFromLevel(2);
            const pathName = importDeclaration.source.value;
            let importSpecifierName = 'default';
            if ((0, ast_helpers_1.isImportSpecifier)(astPath)) {
                importSpecifierName = this.getImportSpecifierName(importDeclaration, position);
            }
            const pathParts = pathName.split('/');
            let maybeAppName = pathParts.shift();
            if (maybeAppName && maybeAppName.startsWith('@')) {
                maybeAppName = maybeAppName + '/' + pathParts.shift();
            }
            let potentialPaths;
            const addonInfo = project.addonsMeta.find(({ name }) => pathName.startsWith(name + '/tests'));
            // If the start of the pathname is same as the project name, then use that as the root.
            if (project.name === maybeAppName && pathName.startsWith(project.name + '/tests')) {
                const importPaths = this.resolvers.resolveTestScopeImport(project.root, pathParts.join(path.sep));
                const existingPaths = await (0, layout_helpers_1.asyncFilter)(importPaths, this.server.fs.exists);
                potentialPaths = await (0, definition_helpers_1.importPathsToLocations)(existingPaths, importSpecifierName);
            }
            else if (addonInfo) {
                const importPaths = this.resolvers.resolveTestScopeImport(addonInfo.root, pathName);
                const existingPaths = await (0, layout_helpers_1.asyncFilter)(importPaths, this.server.fs.exists);
                potentialPaths = await (0, definition_helpers_1.importPathsToLocations)(existingPaths, importSpecifierName);
            }
            else {
                potentialPaths = (await this.guessPathForImport(project.root, uri, pathName, importSpecifierName)) || [];
            }
            definitions = definitions.concat(potentialPaths);
        }
        else if ((0, ast_helpers_1.isServiceInjection)(astPath)) {
            let serviceName = astPath.node.name;
            const args = astPath.parent.value.arguments;
            if (args.length && args[0].type === 'StringLiteral') {
                serviceName = args[0].value;
            }
            definitions = await this.guessPathsForType(root, 'Service', (0, normalizers_1.normalizeServiceName)(serviceName));
        }
        else if ((0, ast_helpers_1.isNamedServiceInjection)(astPath)) {
            const serviceName = astPath.node.value;
            definitions = await this.guessPathsForType(root, 'Service', (0, normalizers_1.normalizeServiceName)(serviceName));
        }
        else if ((0, ast_helpers_1.isRouteLookup)(astPath)) {
            const routePath = astPath.node.value;
            definitions = await (0, template_definition_provider_1.provideRouteDefinition)(this.registry, routePath, this.server.fs);
        }
        return definitions || [];
    }
}
exports.default = CoreScriptDefinitionProvider;
//# sourceMappingURL=script-definition-provider.js.map