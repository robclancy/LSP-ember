import type { File as ASTFile, Node } from '@babel/types';
interface IHbsTagSources {
    [key: string]: string | string[];
}
interface ISearchAndExtractHbsOptions {
    hbsTagSources?: IHbsTagSources;
    parse: (source: string) => ASTFile | never;
}
interface IGetTemplateNodesOptions extends ISearchAndExtractHbsOptions {
    sortByStartKey?: boolean;
}
declare type ITemplateNode = Node & {
    template: string;
    startLine: number;
    startColumn: number;
    endLine: number;
    endColumn: number;
};
export declare const defaultHbsTagSources: IHbsTagSources;
/**
 * Search and extract ember inline templates using the `import declarations`.
 *
 * Extract both **Tagged Template** *hbs\`my tagged template\`* and **Literal String** *hbs('my literal string')*:
 * ```js
 * import hbs from 'htmlbars-inline-precompile';
 *
 * const taggedTemplate = hbs`tagged template`; // valid
 * const fromFunctionCall = hbs('template from function call'); // valid
 * const fromFunctionCallWithArgs = hbs('from function call with args', { moduleId: 'layout.hbs' }); // valid
 * ```
 *
 * ### Options:
 *
 * - `hbsTagSources` - [Optional] The **additional** hbs tag sources used in the import declaration(s), e.g.:
 * ```js
 * {
 *   "hbs-source-with-default-export": "default", // import hbs from 'hbs-source-with-default-export';
 *   "hbs-source-with-named-export" : "handlebars", // import { handlebars } from 'hbs-source-wth-named-export';
 *   "hbs-source-with-renamed-export": "hbs" // import { hbs as h } from 'hbs-source-with-renamed-export';
 * }
 * ```
 *
 * - `babylonPlugins` - [Optional] The **additional** babylon plugins to use, e.g. `[ 'typescipt', 'jsx' ]`, see:
 * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/babylon/index.d.ts#L45.
 *
 * ### Example
 *
 * from:
 * ```ts
 * import GlimmerComponent from '@glimmer/component';
 * import hbs from 'ember-cli-htmlbars-inline-precompile';
 *
 * const template = hbs`
 *   <button
 *     type={{this.type}}
 *   >
 *     {{yield}}
 *   </button>
 * `;
 *
 * class MyButtonComponent extends GlimmerComponent {
 *   type: string = 'button';
 * };
 *
 * export default Ember._setComponentTemplate(template, MyButtonComponent);
 * ```
 * to:
 * ```hbs
 *
 *
 *
 *   <button
 *     type={{this.type}}
 *   >
 *     {{yield}}
 *   </button>
 *
 * ```
 *
 * @param {string} source The script(js/ts) file content.
 * @param {IOptions} options The passed options.
 * @returns {(string | never)} The converted to hbs source.
 * @throws {SyntaxError} Will throw an error if invalid source(ts/js) is passed or a **missing plugin**, e.g. `flow`
 * plugin for **typescript syntax**.
 */
export declare function searchAndExtractHbs(source: string, options: ISearchAndExtractHbsOptions): string | never;
/**
 * Parse the source(js/ts file content) and get only the template nodes array.
 *
 * Template nodes are **TaggedTemplateExpression**, **StringLiteral** and **TemplateLiteral**.
 *
 * ### Options:
 *
 * - `hbsTagSources` - [Optional] The **additional** hbs tag sources used in the import declaration(s), e.g.:
 * ```js
 * {
 *   "hbs-source-with-default-export": "default", // import hbs from 'hbs-source-with-default-export';
 *   "hbs-source-with-named-export" : "handlebars", // import { handlebars } from 'hbs-source-wth-named-export';
 *   "hbs-source-with-renamed-export": "hbs" // import { hbs as h } from 'hbs-source-with-renamed-export';
 * }
 * ```
 *
 * - `parse` - [Optional] parser function.
 *
 * - `sortByStartKey` - [Optional] The extracted template nodes from the **ast** will not be ordered by their original
 * position in the source, so we can sort them using the `start` key, `false` by default.
 *
 * ### Example
 *
 * from:
 * ```js
 * import hbs from 'ember-cli-htmlbars-inline-precompile';
 *
 * const taggedTemplate = hbs`my tagged template`; // `TaggedTemplateExpression` node
 * const stringLiteralTemplate = hbs('my string literal template'); // `StringLiteral` node
 * const templateLiteralTemplate = hbs(`my template literal template`); // `TemplateLiteral` node
 * ```
 * to:
 * ```js
 * [
 *   {
 *     template: 'my tagged template',
 *     startLine: 4,
 *     startColumn: 27,
 *     endLine: 4,
 *     endColumn: 45,
 *     type: 'TemplateElement',
 *     start: 85,
 *     end: 103,
 *     loc: SourceLocation { start: [Position], end: [Position] },
 *     value: { raw: 'my tagged template', cooked: 'my tagged template' },
 *     tail: true
 *   },
 *   {
 *     template: 'my string literal template',
 *     startLine: 5,
 *     startColumn: 35,
 *     endLine: 5,
 *     endColumn: 62,
 *     type: 'StringLiteral',
 *     start: 140,
 *     end: 168,
 *     loc: SourceLocation { start: [Position], end: [Position] },
 *     extra: {
 *       rawValue: 'my string literal template',
 *       raw: "'my string literal template'"
 *     },
 *     value: 'my string literal template'
 *   },
 *   {
 *     template: 'my template literal template',
 *     startLine: 6,
 *     startColumn: 37,
 *     endLine: 6,
 *     endColumn: 65,
 *     type: 'TemplateElement',
 *     start: 208,
 *     end: 236,
 *     loc: SourceLocation { start: [Position], end: [Position] },
 *     value: {
 *       raw: 'my template literal template',
 *       cooked: 'my template literal template'
 *     },
 *     tail: true
 *   }
 * ]
 * ```
 *
 * @param {string} source The script(js/ts) file content.
 * @param {IGetTemplateNodesOptions} options The passed options.
 * @returns {ITemplateNode[]} The extracted template nodes array.
 * @throws {SyntaxError} Will throw an error if invalid source(ts/js) is passed or a **missing plugin**, e.g. `flow`
 * plugin for **typescript syntax**.
 */
export declare function getTemplateNodes(source: string, options: IGetTemplateNodesOptions): ITemplateNode[];
export {};
