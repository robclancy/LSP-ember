"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const addon_api_1 = require("./../utils/addon-api");
const glimmer_utils_1 = require("../glimmer-utils");
const estree_utils_1 = require("../estree-utils");
const fuzzaldrin_1 = require("fuzzaldrin");
const ember_meta_explorer_1 = require("ember-meta-explorer");
// @ts-expect-error esmodule
const uniqBy = require("lodash/uniqBy");
const file_extension_1 = require("../utils/file-extension");
const logger_1 = require("../utils/logger");
const glimmer_script_completion_provider_1 = require("./glimmer-script-completion-provider");
class ScriptCompletionProvider {
    constructor(server) {
        this.server = server;
    }
    async provideCompletions(params) {
        (0, logger_1.logDebugInfo)('provideCompletions');
        const ext = (0, file_extension_1.getExtension)(params.textDocument);
        if (!['.js', '.ts', '.gjs', '.gts'].includes(ext)) {
            return [];
        }
        if (ext === '.gts' || ext === '.gjs') {
            // temporary workaround
            return new glimmer_script_completion_provider_1.default(this.server).provideCompletions(params);
        }
        const uri = params.textDocument.uri;
        const project = this.server.projectRoots.projectForUri(uri);
        if (!project) {
            return [];
        }
        const document = this.server.documents.get(uri);
        if (!document) {
            return [];
        }
        const { root } = project;
        const content = document.getText();
        let ast = null;
        try {
            ast = (0, ember_meta_explorer_1.parseScriptFile)(content);
        }
        catch (e) {
            return [];
        }
        const focusPath = glimmer_utils_1.default.toPosition(ast, (0, estree_utils_1.toPosition)(params.position), content);
        if (!focusPath || !project || !document) {
            return [];
        }
        let textPrefix = focusPath.node.value || '';
        // it's likely hbs template literal, no specific prefix to autocomplete
        if (focusPath.node.type === 'TemplateElement') {
            textPrefix = '';
        }
        if (typeof textPrefix !== 'string') {
            if (textPrefix.raw) {
                textPrefix = textPrefix.raw || '';
            }
            else {
                textPrefix = '';
            }
        }
        const position = Object.freeze({ ...params.position });
        const completions = await (0, addon_api_1.queryELSAddonsAPIChain)(project.builtinProviders.completionProviders, root, {
            focusPath,
            textDocument: params.textDocument,
            position,
            server: this.server,
            results: [],
            type: 'script',
        });
        const addonResults = await (0, addon_api_1.queryELSAddonsAPIChain)(project.providers.completionProviders, root, {
            focusPath,
            textDocument: params.textDocument,
            position,
            server: this.server,
            results: completions,
            type: 'script',
        });
        return (0, fuzzaldrin_1.filter)(uniqBy(addonResults, 'label'), textPrefix, {
            key: 'label',
            maxResults: 40,
        });
    }
}
exports.default = ScriptCompletionProvider;
//# sourceMappingURL=script-completion-provider.js.map