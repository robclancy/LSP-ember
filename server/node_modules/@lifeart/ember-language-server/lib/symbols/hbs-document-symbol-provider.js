"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("vscode-languageserver/node");
const syntax_1 = require("@glimmer/syntax");
const estree_utils_1 = require("../estree-utils");
const logger_1 = require("../utils/logger");
class HBSDocumentSymbolProvider {
    constructor() {
        this.extensions = ['.hbs'];
    }
    process(content) {
        const symbols = [];
        try {
            const ast = (0, syntax_1.preprocess)(content);
            (0, syntax_1.traverse)(ast, {
                ElementNode(node) {
                    if (node.tag.charAt(0) === node.tag.charAt(0).toUpperCase()) {
                        symbols.push(node_1.SymbolInformation.create(node.tag, node_1.SymbolKind.Variable, (0, estree_utils_1.toLSRange)(node.loc)));
                    }
                },
                BlockStatement(node) {
                    if (node.hash.pairs.length) {
                        node.hash.pairs.forEach((pair) => {
                            symbols.push(node_1.SymbolInformation.create(pair.key, node_1.SymbolKind.Property, (0, estree_utils_1.toLSRange)(pair.loc)));
                        });
                    }
                    if (node.program.blockParams.length === 0)
                        return;
                    node.program.blockParams.forEach((blockParam) => {
                        const symbol = node_1.SymbolInformation.create(blockParam, node_1.SymbolKind.Variable, (0, estree_utils_1.toLSRange)(node.loc));
                        symbols.push(symbol);
                    });
                },
                MustacheStatement(node) {
                    if (node.hash.pairs.length) {
                        node.hash.pairs.forEach((pair) => {
                            symbols.push(node_1.SymbolInformation.create(pair.key, node_1.SymbolKind.Property, (0, estree_utils_1.toLSRange)(pair.loc)));
                        });
                    }
                    if (node.path.type === 'PathExpression') {
                        if (node.path.head.type === 'AtHead') {
                            const symbol = node_1.SymbolInformation.create(node.path.original, node_1.SymbolKind.Variable, (0, estree_utils_1.toLSRange)(node.path.loc));
                            symbols.push(symbol);
                        }
                    }
                },
            });
        }
        catch (e) {
            (0, logger_1.logDebugInfo)('symbolprovider:template:error', e, e.toString(), e.stack);
        }
        return symbols;
    }
}
exports.default = HBSDocumentSymbolProvider;
//# sourceMappingURL=hbs-document-symbol-provider.js.map