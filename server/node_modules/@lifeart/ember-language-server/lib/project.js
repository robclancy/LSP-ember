"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Project = void 0;
const registry_api_1 = require("./utils/registry-api");
const addon_api_1 = require("./utils/addon-api");
const layout_helpers_1 = require("./utils/layout-helpers");
const base_project_1 = require("./base-project");
const path = require("path");
const logger_1 = require("./utils/logger");
const vscode_uri_1 = require("vscode-uri");
const builtin_addons_initializer_1 = require("./utils/builtin-addons-initializer");
class Project extends base_project_1.BaseProject {
    constructor(root, addons = [], pkg = {}) {
        super(root);
        this.root = root;
        this.addonsMeta = [];
        this.dependenciesMeta = [];
        this.executors = {};
        this.watchers = [];
        this.destructors = [];
        this.linters = [];
        this.initIssues = [];
        this.files = new Map();
        this.registryVersion = 0;
        this._registryVersion = -1;
        this.flags = {
            enableEagerRegistryInitialization: true,
        };
        this.addons = addons;
        this.addonsMeta = [];
        this._packageJSON = pkg;
        // for now, let's collect only interesting deps
        const interestingDeps = ['ember-cli', 'ember-source', 'ember-template-lint', 'typescript', '@embroider/core'];
        interestingDeps.forEach((dep) => {
            const version = (0, layout_helpers_1.getDepIfExists)(pkg, dep);
            if (version !== null) {
                this.dependenciesMeta.push({
                    name: dep,
                    version,
                });
            }
        });
    }
    get roots() {
        const mainRoot = this.root;
        const otherRoots = this.addonsMeta.filter((addon) => addon.version !== null).map((meta) => meta.root);
        // because all registry searches based on "startsWith", we could omit roots in same namespace,
        // like {root/a, root/b}, because we will get results of it from {root} itself
        const differentRoots = otherRoots.filter((root) => !(0, layout_helpers_1.isRootStartingWithFilePath)(mainRoot, root));
        return [mainRoot, ...differentRoots];
    }
    invalidateRegistry() {
        this._registryVersion = -1;
    }
    get registry() {
        if (this._registryVersion !== this.registryVersion) {
            (0, logger_1.logInfo)(`${this.name} registry version mismatch [${this._registryVersion}, ${this.registryVersion}], regenerating...`);
            const start = Date.now();
            this._registry = (0, registry_api_1.getRegistryForRoots)(this.roots);
            this._registryVersion = this.registryVersion;
            (0, logger_1.logInfo)(`${this.name} registry generated in ${Date.now() - start}ms, new version: ${this._registryVersion}`);
        }
        return this._registry;
    }
    trackChange(uri, change) {
        // prevent leaks
        if (this.files.size > 10000) {
            this.registryVersion++;
            (0, logger_1.logError)(new Error('too many files for project ' + this.root));
            this.files.clear();
        }
        const rawPath = vscode_uri_1.URI.parse(uri).fsPath;
        if (!rawPath) {
            return;
        }
        const filePath = path.resolve(rawPath);
        const item = this.matchPathToType(filePath);
        let normalizedItem = undefined;
        if (item) {
            normalizedItem = (0, registry_api_1.normalizeMatchNaming)(item);
        }
        if (change === 3) {
            this.registryVersion++;
            this.files.delete(filePath);
            if (normalizedItem) {
                (0, registry_api_1.removeFromRegistry)(normalizedItem.name, normalizedItem.type, [filePath]);
            }
        }
        else {
            if (normalizedItem) {
                if (!(0, registry_api_1.existsInRegistry)(normalizedItem.name, normalizedItem.type, filePath)) {
                    this.registryVersion++;
                }
                // we still call it, because for template case, we have to update it's tokens
                (0, registry_api_1.addToRegistry)(normalizedItem.name, normalizedItem.type, [filePath]);
            }
            if (!this.files.has(filePath)) {
                this.files.set(filePath, { version: 0 });
            }
            const file = this.files.get(filePath);
            if (file) {
                file.version++;
            }
        }
        this.watchers.forEach((cb) => cb(uri, change));
    }
    addCommandExecutor(key, cb) {
        this.executors[key] = cb;
    }
    addLinter(cb) {
        this.linters.push(cb);
    }
    addWatcher(cb) {
        this.watchers.push(cb);
    }
    get packageJSON() {
        return this._packageJSON;
    }
    get name() {
        var _a;
        return (_a = this.packageJSON.name) !== null && _a !== void 0 ? _a : '[Unknown Project]';
    }
    async initialize(server) {
        if (server.options.type === 'worker') {
            this.providers = (0, addon_api_1.emptyProjectProviders)();
            this.flags.enableEagerRegistryInitialization = false;
        }
        else if (server.options.type === 'node') {
            this.providers = await (0, addon_api_1.collectProjectProviders)(this.root, this.addons);
        }
        else {
            throw new Error(`Unknown server type: "${server.options.type}"`);
        }
        this.addonsMeta = this.providers.addonsMeta.filter((el) => el.root !== this.root);
        this.builtinProviders = (0, builtin_addons_initializer_1.initBuiltinProviders)(this.addonsMeta);
    }
    addonForFile(filePath) {
        return this.addonsMeta.find((el) => filePath.startsWith(el.root));
    }
    async unload() {
        this.initIssues = [];
        for (const fn of this.destructors) {
            try {
                await fn(this);
            }
            catch (e) {
                (0, logger_1.logError)(e);
            }
        }
        this.files.clear();
        this.destructors = [];
        this.linters = [];
        this.watchers = [];
        this.executors = {};
        (0, logger_1.logInfo)('--------------------');
        (0, logger_1.logInfo)(`Ember CLI project: ${this.root} unloaded`);
        (0, logger_1.logInfo)('--------------------');
    }
    async init(server) {
        for (const initFn of this.providers.initFunctions) {
            try {
                const initResult = await initFn(server, this);
                if (typeof initResult === 'function') {
                    this.destructors.push(initResult);
                }
            }
            catch (e) {
                (0, logger_1.logError)(e);
                this.initIssues.push(e.toString());
                this.initIssues.push(e.stack);
            }
        }
        for (const initFn of this.builtinProviders.initFunctions) {
            try {
                const initResult = await initFn(server, this);
                if (typeof initResult === 'function') {
                    this.destructors.push(initResult);
                }
            }
            catch (e) {
                (0, logger_1.logError)(e);
                this.initIssues.push(e.toString());
                this.initIssues.push(e.stack);
            }
        }
        if (this.flags.enableEagerRegistryInitialization) {
            // prefer explicit registry tree building
            await Promise.all([(0, layout_helpers_1.findTestsForProject)(this), (0, layout_helpers_1.findAppItemsForProject)(this), (0, layout_helpers_1.findAddonItemsForProject)(this)]);
        }
        if (this.providers.info.length) {
            (0, logger_1.logInfo)('--------------------');
            (0, logger_1.logInfo)('loaded language server addons:');
            this.providers.info.forEach((addonName) => {
                (0, logger_1.logInfo)('    ' + addonName);
            });
            (0, logger_1.logInfo)('--------------------');
        }
        if (this.initIssues.length) {
            (0, logger_1.logInfo)('---- Found init issues: -----');
            this.initIssues.forEach((issue) => {
                (0, logger_1.logInfo)('--------------------');
                (0, logger_1.logInfo)(issue);
                (0, logger_1.logInfo)('--------------------');
            });
        }
    }
}
__decorate([
    layout_helpers_1.cached
], Project.prototype, "roots", null);
__decorate([
    layout_helpers_1.cached
], Project.prototype, "packageJSON", null);
exports.Project = Project;
//# sourceMappingURL=project.js.map