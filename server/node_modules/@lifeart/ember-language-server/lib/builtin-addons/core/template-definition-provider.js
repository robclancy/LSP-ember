"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.provideRouteDefinition = exports.provideComponentTemplatePaths = exports.getPathsFromRegistry = void 0;
const path = require("path");
const ast_helpers_1 = require("./../../utils/ast-helpers");
const glimmer_utils_1 = require("./../../glimmer-utils");
const normalizers_1 = require("../../utils/normalizers");
const layout_helpers_1 = require("./../../utils/layout-helpers");
const definition_helpers_1 = require("./../../utils/definition-helpers");
const vscode_uri_1 = require("vscode-uri");
const layout_helpers_2 = require("../../utils/layout-helpers");
const usages_api_1 = require("../../utils/usages-api");
function getComponentAndAddonName(rawComponentName) {
    const componentParts = rawComponentName.split('$');
    const addonName = componentParts.length > 1 ? componentParts[0] : '';
    // If the component name doesnt have a batman syntax then just return the name of the component
    // Else returns the name of the component.
    const componentName = componentParts.pop();
    return { addonName: (0, normalizers_1.normalizeToClassicComponent)(addonName), componentName };
}
function getPathsFromRegistry(type, name, registry) {
    const bucket = registry[type][name] || [];
    return bucket.filter((el) => !(0, layout_helpers_2.isStyleFile)(path.normalize(el)) && !(0, layout_helpers_1.isTestFile)(path.normalize(el)));
}
exports.getPathsFromRegistry = getPathsFromRegistry;
function provideComponentTemplatePaths(registry, rawComponentName) {
    const maybeComponentName = (0, normalizers_1.normalizeToClassicComponent)(rawComponentName);
    const items = getPathsFromRegistry('component', maybeComponentName, registry);
    if (items.length) {
        const results = items.filter((el) => (0, layout_helpers_1.isTemplatePath)(el));
        if (results.length) {
            return results;
        }
        else {
            return [];
        }
    }
    else {
        return [];
    }
}
exports.provideComponentTemplatePaths = provideComponentTemplatePaths;
async function provideRouteDefinition(registry, routeName, fs) {
    const items = getPathsFromRegistry('routePath', routeName, registry).filter((el) => !(0, layout_helpers_1.isTestFile)(el));
    const existingItems = await (0, layout_helpers_1.asyncFilter)(items, fs.exists);
    return (0, definition_helpers_1.pathsToLocations)(...existingItems);
}
exports.provideRouteDefinition = provideRouteDefinition;
class TemplateDefinitionProvider {
    get registry() {
        return this.project.registry;
    }
    async onInit(server, project) {
        this.server = server;
        this.project = project;
    }
    async onDefinition(_, params) {
        const uri = params.textDocument.uri;
        const focusPath = params.focusPath;
        let definitions = params.results;
        if (params.type !== 'template') {
            return params.results;
        }
        if ((0, ast_helpers_1.isOutlet)(focusPath)) {
            definitions = await this.provideChildRouteDefinitions(uri);
        }
        else if (this.maybeClassicComponentName(focusPath)) {
            const { addonName, componentName } = getComponentAndAddonName(this.extractValueForMaybeClassicComponentName(focusPath));
            // <FooBar @some-component-name="my-component" /> || {{some-component some-name="my-component/name"}}
            definitions = await this.provideComponentDefinition(componentName, addonName);
        }
        else if (this.isAngleComponent(focusPath)) {
            // <FooBar />
            definitions = await this.provideAngleBrackedComponentDefinition(focusPath);
            // {{#foo-bar}} {{/foo-bar}}
        }
        else if (this.isMayBeComponentFromPath(focusPath)) {
            const [key, ...tail] = focusPath.node.tag.split('.');
            const scopes = (0, glimmer_utils_1.getLocalScope)(focusPath);
            const target = scopes.find((el) => el.name === key);
            if (target) {
                const keyPath = `${target.slotName}:${target.index}:${tail.join('.')}`;
                const allTokens = (0, usages_api_1.getAllTemplateTokens)().component;
                const meta = allTokens[target.componentName];
                if (meta.yieldScopes && meta.yieldScopes[keyPath]) {
                    const info = meta.yieldScopes[keyPath];
                    if (info) {
                        const [kind, name] = info;
                        const names = Array.isArray(name) ? name : [name];
                        const data = names.map((itemName) => getPathsFromRegistry(kind, itemName, this.registry));
                        definitions = (0, definition_helpers_1.pathsToLocations)(...data.reduce((acc, curr) => acc.concat(curr), []));
                    }
                }
            }
        }
        else if (this.isComponentWithBlock(focusPath)) {
            definitions = await this.provideBlockComponentDefinition(focusPath);
            // {{action "fooBar"}}, (action "fooBar"), (action this.fooBar), this.someProperty
        }
        else if (this.isActionName(focusPath) || this.isLocalProperty(focusPath)) {
            definitions = await this.providePropertyDefinition(focusPath, uri);
            // {{foo-bar}}
        }
        else if (this.isComponentOrHelperName(focusPath)) {
            definitions = await this.provideMustacheDefinition(focusPath);
            // <FooBar @somePropertyToFindUsage="" />
        }
        else if ((0, ast_helpers_1.isLinkComponentRouteTarget)(focusPath)) {
            // <LinkTo @route="name" />
            definitions = await this.provideRouteDefinition(focusPath.node.chars);
        }
        else if (this.isAnglePropertyAttribute(focusPath)) {
            definitions = await this.provideAngleBracketComponentAttributeUsage(focusPath);
            // {{hello propertyUsageToFind=someValue}}
        }
        else if (this.isHashPairKey(focusPath)) {
            definitions = await this.provideHashPropertyUsage(focusPath);
        }
        else if ((0, ast_helpers_1.isLinkToTarget)(focusPath)) {
            definitions = await this.provideRouteDefinition(focusPath.node.original);
        }
        return definitions;
    }
    looksLikeClassicComponentName(name) {
        return name.length && !name.includes('.') && !name.includes(' ') && name === name.toLowerCase();
    }
    extractValueForMaybeClassicComponentName(focusPath) {
        let value = '';
        const node = focusPath.node;
        const parent = focusPath.parent;
        if (!parent) {
            return value;
        }
        if (node.type === 'StringLiteral' && parent.type === 'HashPair') {
            value = node.original;
        }
        else if (node.type === 'TextNode' && parent.type === 'AttrNode') {
            value = node.chars;
        }
        return value;
    }
    maybeClassicComponentName(focusPath) {
        const value = this.extractValueForMaybeClassicComponentName(focusPath);
        if (this.looksLikeClassicComponentName(value)) {
            return true;
        }
        else {
            return false;
        }
    }
    async provideRouteDefinition(routeName) {
        return await provideRouteDefinition(this.registry, routeName, this.server.fs);
    }
    _provideLikelyRawComponentTemplatePaths(rawComponentName, addonName) {
        const maybeComponentName = (0, normalizers_1.normalizeToClassicComponent)(rawComponentName);
        let paths = getPathsFromRegistry('component', maybeComponentName, this.registry);
        if (addonName) {
            const addonMeta = this.project.addonsMeta.find((el) => el.name === addonName);
            if (addonMeta) {
                paths = paths.filter((p) => {
                    return p.startsWith(addonMeta.root);
                });
            }
        }
        return paths;
    }
    async provideLikelyComponentTemplatePath(rawComponentName) {
        // Check for batman syntax <Foo$Bar>
        const { addonName, componentName } = getComponentAndAddonName(rawComponentName);
        const paths = new Set();
        const localPaths = this._provideLikelyRawComponentTemplatePaths(componentName, addonName);
        localPaths.forEach((p) => {
            paths.add(p);
        });
        const selectedPaths = paths.size > 1 ? Array.from(paths).filter((postfix) => (0, layout_helpers_1.isTemplatePath)(postfix)) : Array.from(paths);
        const existingPaths = await (0, layout_helpers_1.asyncFilter)(selectedPaths, this.server.fs.exists);
        return (0, definition_helpers_1.pathsToLocations)(...existingPaths);
    }
    provideAngleBrackedComponentDefinition(focusPath) {
        return this.provideLikelyComponentTemplatePath(focusPath.node.tag);
    }
    async provideBlockComponentDefinition(focusPath) {
        const maybeComponentName = (0, normalizers_1.normalizeToClassicComponent)(focusPath.node.path.original);
        const paths = getPathsFromRegistry('component', maybeComponentName, this.registry).filter((el) => (0, layout_helpers_1.isTemplatePath)(el));
        const existingPaths = await (0, layout_helpers_1.asyncFilter)(paths, this.server.fs.exists);
        // mAddonPathsForComponentTemplates
        return (0, definition_helpers_1.pathsToLocationsWithPosition)(existingPaths, '{{yield');
    }
    async provideChildRouteDefinitions(uri) {
        const rawPath = vscode_uri_1.URI.parse(uri).fsPath.toLowerCase();
        const registry = this.registry;
        const allPaths = registry.routePath;
        let pathName = null;
        const paths = [];
        Object.keys(allPaths).forEach((name) => {
            const files = allPaths[name].map((item) => item.toLowerCase());
            if (files.includes(rawPath)) {
                pathName = name;
            }
            else {
                paths.push(name);
            }
        });
        if (pathName === null || paths.length === 0) {
            return [];
        }
        const files = [];
        const distance = 2;
        const interestingPaths = paths
            .filter((p) => {
            if (pathName === 'application') {
                return p.split('.').length <= distance;
            }
            if (!p.startsWith(`${pathName}.`)) {
                return false;
            }
            return p.replace(pathName, '').split('.').length <= distance;
        })
            .sort();
        interestingPaths.forEach((p) => {
            const registryItem = registry.routePath[p] || [];
            const items = registryItem.filter((el) => {
                return !(0, layout_helpers_1.isTestFile)(path.normalize(el)) && (0, layout_helpers_1.isTemplatePath)(el);
            });
            if (items.length) {
                files.push(items[0]);
            }
        });
        const existingFiles = await (0, layout_helpers_1.asyncFilter)(files, this.server.fs.exists);
        return (0, definition_helpers_1.pathsToLocations)(...existingFiles);
    }
    async providePropertyDefinition(focusPath, uri) {
        const rawPath = vscode_uri_1.URI.parse(uri).fsPath;
        if (!rawPath) {
            return Promise.resolve([]);
        }
        const filePath = path.resolve(rawPath);
        const data = this.project.matchPathToType(filePath);
        if (data === null || data.type !== 'component') {
            return Promise.resolve([]);
        }
        const maybeComponentName = (0, normalizers_1.normalizeToClassicComponent)(data.name);
        const paths = getPathsFromRegistry('component', maybeComponentName, this.registry).filter((el) => (0, layout_helpers_1.isScriptPath)(el));
        const existingPaths = await (0, layout_helpers_1.asyncFilter)(paths, this.server.fs.exists);
        const text = focusPath.node.original;
        return (0, definition_helpers_1.pathsToLocationsWithPosition)(existingPaths, text.replace('this.', '').split('.')[0]);
    }
    async provideComponentDefinition(rawComponentName, addonName) {
        const maybeComponentName = (0, normalizers_1.normalizeToClassicComponent)(rawComponentName);
        let paths = [...getPathsFromRegistry('component', maybeComponentName, this.registry), ...getPathsFromRegistry('helper', maybeComponentName, this.registry)];
        if (addonName) {
            const addonMeta = this.project.addonsMeta.find((el) => el.name === addonName);
            if (addonMeta) {
                paths = paths.filter((p) => {
                    return p.startsWith(addonMeta.root);
                });
            }
        }
        const selectedPaths = paths.length > 1 ? paths.filter(layout_helpers_1.isTemplatePath) : paths;
        const existingPaths = await (0, layout_helpers_1.asyncFilter)(selectedPaths, this.server.fs.exists);
        return (0, definition_helpers_1.pathsToLocations)(...existingPaths);
    }
    provideMustacheDefinition(focusPath) {
        const maybeComponentName = focusPath.node.type === 'ElementNode'
            ? (0, normalizers_1.normalizeToClassicComponent)(focusPath.node.tag)
            : focusPath.node.original;
        const { addonName, componentName } = getComponentAndAddonName(maybeComponentName);
        return this.provideComponentDefinition(componentName, addonName);
    }
    async provideHashPropertyUsage(focusPath) {
        const parentPath = focusPath.parentPath;
        if (parentPath && parentPath.parent && parentPath.parent.path) {
            const maybeComponentName = parentPath.parent.path.original;
            if (!maybeComponentName.includes('.') && maybeComponentName.includes('-')) {
                const paths = getPathsFromRegistry('component', maybeComponentName, this.registry).filter((postfix) => (0, layout_helpers_1.isTemplatePath)(postfix));
                const existingPaths = await (0, layout_helpers_1.asyncFilter)(paths, this.server.fs.exists);
                return (0, definition_helpers_1.pathsToLocationsWithPosition)(existingPaths, '@' + focusPath.node.key);
            }
        }
        return Promise.resolve([]);
    }
    async provideAngleBracketComponentAttributeUsage(focusPath) {
        const maybeComponentName = (0, normalizers_1.normalizeToClassicComponent)(focusPath.parent.tag);
        const paths = getPathsFromRegistry('component', maybeComponentName, this.registry).filter((postfix) => (0, layout_helpers_1.isTemplatePath)(postfix));
        const existingPaths = await (0, layout_helpers_1.asyncFilter)(paths, this.server.fs.exists);
        return (0, definition_helpers_1.pathsToLocationsWithPosition)(existingPaths, focusPath.node.name);
    }
    isLocalProperty(path) {
        const node = path.node;
        if (node.type === 'PathExpression') {
            return node.head.type === 'ThisHead';
        }
        return false;
    }
    isHashPairKey(path) {
        const node = path.node;
        return node.type === 'HashPair';
    }
    isAnglePropertyAttribute(path) {
        const node = path.node;
        if (node.type === 'AttrNode') {
            if (node.name.charAt(0) === '@') {
                return true;
            }
        }
    }
    isActionName(path) {
        const node = path.node;
        if (!path.parent) {
            return false;
        }
        if (path.parent.type !== 'MustacheStatement' &&
            path.parent.type !== 'PathExpression' &&
            path.parent.type !== 'SubExpression' &&
            path.parent.type !== 'ElementModifierStatement') {
            return false;
        }
        // @ts-expect-error @todo - fix typings
        if (!path.parent || path.parent.path.original !== 'action' || !path.parent.params[0] === node) {
            return false;
        }
        if (node.type === 'StringLiteral') {
            return true;
        }
        else if (node.type === 'PathExpression' && node.head.type === 'ThisHead') {
            return true;
        }
        return false;
    }
    isComponentWithBlock(path) {
        const node = path.node;
        return (node.type === 'BlockStatement' &&
            node.path.type === 'PathExpression' &&
            node.path.head.type !== 'ThisHead' &&
            node.path.original.includes('-') &&
            node.path.original.charAt(0) !== '-' &&
            !node.path.original.includes('.'));
    }
    isMayBeComponentFromPath(path) {
        const node = path.node;
        if (node.type === 'ElementNode') {
            if (node.tag.indexOf('.') > -1) {
                return true;
            }
        }
    }
    isAngleComponent(path) {
        const node = path.node;
        if (node.type === 'ElementNode') {
            if (node.tag.charAt(0) === node.tag.charAt(0).toUpperCase()) {
                return true;
            }
        }
    }
    isComponentOrHelperName(path) {
        const node = path.node;
        if (this.isAngleComponent(path)) {
            return true;
        }
        const parent = path.parent;
        if (node.type === 'StringLiteral') {
            if (parent && parent.path && parent.path.original === 'component' && parent.params[0] === node) {
                return true;
            }
        }
        if (node.type !== 'PathExpression') {
            return false;
        }
        if (!parent || parent.path !== node || (parent.type !== 'MustacheStatement' && parent.type !== 'BlockStatement' && parent.type !== 'SubExpression')) {
            return false;
        }
        return true;
    }
}
exports.default = TemplateDefinitionProvider;
//# sourceMappingURL=template-definition-provider.js.map