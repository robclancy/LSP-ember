"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.listRoutes = exports.listTransforms = exports.listHelpers = exports.listServices = exports.listModels = exports.listModifiers = exports.findAddonItemsForProject = exports.findAppItemsForProject = exports.findTestsForProject = exports.listComponents = exports.hasNamespaceSupport = exports.builtinModifiers = exports.listPodsComponents = exports.getProjectAddonsInfo = exports.hasAddonFolderInPath = exports.isTestFile = exports.isStyleFile = exports.normalizedPath = exports.isScriptPath = exports.isTemplatePath = exports.addonVersion = exports.isEmberAddon = exports.asyncGetJSON = exports.asyncGetPackageJSON = exports.getProjectAddonsRoots = exports.isGlimmerXProject = exports.getDepIfExists = exports.getProjectInRepoAddonsRoots = exports.cached = exports.isELSAddonRoot = exports.isFileBelongsToRoots = exports.isRootStartingWithFilePath = exports.resolvePackageRoot = exports.getPodModulePrefix = exports.safeWalkAsync = exports.getRequireSupport = exports.setRequireSupport = exports.getSyncFSSupport = exports.setSyncFSSupport = exports.mGetProjectAddonsInfo = exports.podModulePrefixForRoot = exports.hasEmberLanguageServerExtension = exports.normalizeRoutePath = exports.asyncFilter = exports.ADDON_CONFIG_KEY = void 0;
const memoize = require("memoizee");
const path = require("path");
const node_1 = require("vscode-languageserver/node");
const registry_api_1 = require("./registry-api");
const semver_1 = require("semver");
const base_project_1 = require("../base-project");
const fs_provider_1 = require("../fs-provider");
const walk_async_1 = require("./walk-async");
// const GLOBAL_REGISTRY = ['primitive-name'][['relatedFiles']];
exports.ADDON_CONFIG_KEY = 'ember-language-server';
async function asyncFilter(arr, predicate) {
    const results = await Promise.all(arr.map((e) => predicate(e)));
    return arr.filter((_v, index) => results[index]);
}
exports.asyncFilter = asyncFilter;
function normalizeRoutePath(name) {
    return name.split('/').join('.');
}
exports.normalizeRoutePath = normalizeRoutePath;
function hasEmberLanguageServerExtension(info) {
    return info[exports.ADDON_CONFIG_KEY] !== undefined;
}
exports.hasEmberLanguageServerExtension = hasEmberLanguageServerExtension;
exports.podModulePrefixForRoot = memoize(getPodModulePrefix, {
    length: 1,
    maxAge: 60000,
});
exports.mGetProjectAddonsInfo = memoize(getProjectAddonsInfo, {
    length: 1,
    maxAge: 600000,
}); // 1 second
let _supportSyncFS = true;
let _requireSupport = true;
function setSyncFSSupport(value) {
    _supportSyncFS = value;
}
exports.setSyncFSSupport = setSyncFSSupport;
function getSyncFSSupport() {
    return _supportSyncFS;
}
exports.getSyncFSSupport = getSyncFSSupport;
function setRequireSupport(value) {
    _requireSupport = value;
}
exports.setRequireSupport = setRequireSupport;
function getRequireSupport() {
    return _requireSupport;
}
exports.getRequireSupport = getRequireSupport;
async function safeWalkAsync(filePath, opts) {
    if (!filePath) {
        return [];
    }
    if (!(await (0, fs_provider_1.fsProvider)().exists(filePath))) {
        return [];
    }
    return await (0, walk_async_1.default)(filePath, { ...opts, fs: (0, fs_provider_1.fsProvider)() });
}
exports.safeWalkAsync = safeWalkAsync;
function getPodModulePrefix(root) {
    let podModulePrefix = '';
    // logDebugInfo('listPodsComponents');
    try {
        if (!getRequireSupport()) {
            return null;
        }
        // @ts-expect-error @todo - fix webpack imports
        const requireFunc = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const appConfig = requireFunc(path.join(root, 'config', 'environment.js'));
        // logDebugInfo('appConfig', appConfig);
        podModulePrefix = appConfig('development').podModulePrefix || '';
        if (podModulePrefix.includes('/')) {
            podModulePrefix = podModulePrefix.split('/').pop();
        }
    }
    catch (e) {
        // logDebugInfo('catch', e);
        return null;
    }
    if (!podModulePrefix) {
        return null;
    }
    return podModulePrefix.trim().length > 0 ? podModulePrefix : null;
}
exports.getPodModulePrefix = getPodModulePrefix;
async function resolvePackageRoot(root, addonName, packagesFolder = 'node_modules') {
    const roots = root.split(path.sep);
    while (roots.length) {
        const prefix = roots.join(path.sep);
        const maybePath = path.join(prefix, packagesFolder, addonName);
        const linkedPath = path.join(prefix, addonName);
        if (await (0, fs_provider_1.fsProvider)().exists(path.join(maybePath, 'package.json'))) {
            return maybePath;
        }
        else if (await (0, fs_provider_1.fsProvider)().exists(path.join(linkedPath, 'package.json'))) {
            return linkedPath;
        }
        roots.pop();
    }
    return false;
}
exports.resolvePackageRoot = resolvePackageRoot;
/**
 * Returns true if file path starts with the given root path.
 * There are cases where the root path might be
 * 'foo/bar/biz' and 'foo/bar/biz-bar'. The startsWith/includes will always
 * return true for both these roots. Hence having a stricter check will help
 * @param rootPath root path
 * @param filePath file path
 * @returns boolean
 */
function isRootStartingWithFilePath(rootPath, filePath) {
    if (!filePath.startsWith(rootPath)) {
        return false;
    }
    const filePathParts = normalizedPath(filePath).split('/');
    const rootParts = normalizedPath(rootPath).split('/');
    return rootParts.every((item, idx) => filePathParts[idx] === item);
}
exports.isRootStartingWithFilePath = isRootStartingWithFilePath;
function isFileBelongsToRoots(roots, filePath) {
    return roots.some((root) => isRootStartingWithFilePath(root, filePath));
}
exports.isFileBelongsToRoots = isFileBelongsToRoots;
async function isProjectAddonRoot(root) {
    const pack = await asyncGetPackageJSON(root);
    const hasIndexJs = await (0, fs_provider_1.fsProvider)().exists(path.join(root, 'index.js'));
    return isEmberAddon(pack) && hasIndexJs;
}
async function isELSAddonRoot(root) {
    const pack = await asyncGetPackageJSON(root);
    return hasEmberLanguageServerExtension(pack);
}
exports.isELSAddonRoot = isELSAddonRoot;
function cached(_proto, prop, desc) {
    const values = new WeakMap();
    return {
        get() {
            var _a;
            if (!values.has(this)) {
                values.set(this, {});
            }
            const objects = values.get(this);
            if (!(prop in objects)) {
                objects[prop] = (_a = desc.get) === null || _a === void 0 ? void 0 : _a.call(this);
            }
            return objects[prop];
        },
    };
}
exports.cached = cached;
async function getRecursiveInRepoAddonRoots(root, roots) {
    const packageData = await asyncGetPackageJSON(root);
    const emberAddonPaths = (packageData['ember-addon'] && packageData['ember-addon'].paths) || [];
    if (roots.length) {
        if (!isEmberAddon(packageData)) {
            return [];
        }
    }
    const recursiveRoots = roots.slice(0);
    const normalizedPaths = emberAddonPaths.map((relativePath) => path.normalize(path.join(root, relativePath)));
    const validPaths = await asyncFilter(normalizedPaths, isProjectAddonRoot);
    for (const validRoot of validPaths) {
        const packInfo = await asyncGetPackageJSON(validRoot);
        // we don't need to go deeper if package itself not an ember-addon or els-extension
        if (!isEmberAddon(packInfo) && !hasEmberLanguageServerExtension(packInfo)) {
            continue;
        }
        if (!recursiveRoots.includes(validRoot)) {
            recursiveRoots.push(validRoot);
            const items = await getRecursiveInRepoAddonRoots(validRoot, recursiveRoots);
            items.forEach((relatedRoot) => {
                if (!recursiveRoots.includes(relatedRoot)) {
                    recursiveRoots.push(relatedRoot);
                }
            });
        }
    }
    return recursiveRoots.sort();
}
async function getProjectInRepoAddonsRoots(root) {
    const roots = await getRecursiveInRepoAddonRoots(root, []);
    return Array.from(new Set(roots));
}
exports.getProjectInRepoAddonsRoots = getProjectInRepoAddonsRoots;
function hasDep(pack, depName) {
    if (pack.dependencies && pack.dependencies[depName]) {
        return true;
    }
    if (pack.devDependencies && pack.devDependencies[depName]) {
        return true;
    }
    if (pack.peerDependencies && pack.peerDependencies[depName]) {
        return true;
    }
    return false;
}
function getDepIfExists(pack, depName) {
    var _a, _b, _c, _d, _e, _f;
    if (!hasDep(pack, depName)) {
        return null;
    }
    const version = (_f = (_d = (_b = (_a = pack === null || pack === void 0 ? void 0 : pack.dependencies) === null || _a === void 0 ? void 0 : _a[depName]) !== null && _b !== void 0 ? _b : (_c = pack === null || pack === void 0 ? void 0 : pack.devDependencies) === null || _c === void 0 ? void 0 : _c[depName]) !== null && _d !== void 0 ? _d : (_e = pack === null || pack === void 0 ? void 0 : pack.peerDependencies) === null || _e === void 0 ? void 0 : _e[depName]) !== null && _f !== void 0 ? _f : '';
    const cleanVersion = (0, semver_1.clean)(version);
    return (0, semver_1.valid)((0, semver_1.coerce)(cleanVersion));
}
exports.getDepIfExists = getDepIfExists;
async function isGlimmerXProject(root) {
    const pack = await asyncGetPackageJSON(root);
    return hasDep(pack, '@glimmerx/core') || hasDep(pack, 'glimmer-lite-core');
}
exports.isGlimmerXProject = isGlimmerXProject;
async function getProjectAddonsRoots(root, resolvedItems = [], packageFolderName = 'node_modules') {
    const pack = await asyncGetPackageJSON(root);
    if (resolvedItems.length) {
        if (!isEmberAddon(pack)) {
            return [];
        }
    }
    const items = resolvedItems.length
        ? [...Object.keys(pack.dependencies || {}), ...Object.keys(pack.peerDependencies || {})]
        : [...Object.keys(pack.dependencies || {}), ...Object.keys(pack.peerDependencies || {}), ...Object.keys(pack.devDependencies || {})];
    // logDebugInfo('items', items);
    const rawRoots = await Promise.all(items.map(async (item) => {
        return await resolvePackageRoot(root, item, packageFolderName);
    }));
    const roots = rawRoots.filter((p) => {
        return p !== false;
    });
    const recursiveRoots = resolvedItems.slice(0);
    const packages = await Promise.all(roots.map((root) => asyncGetPackageJSON(root)));
    for (const rootItem of roots) {
        const packInfo = packages[roots.indexOf(rootItem)];
        // we don't need to go deeper if package itself not an ember-addon or els-extension
        if (!isEmberAddon(packInfo) && !hasEmberLanguageServerExtension(packInfo)) {
            continue;
        }
        if (!recursiveRoots.includes(rootItem)) {
            recursiveRoots.push(rootItem);
            const addonRoots = await getProjectAddonsRoots(rootItem, recursiveRoots, packageFolderName);
            addonRoots.forEach((item) => {
                if (!recursiveRoots.includes(item)) {
                    recursiveRoots.push(item);
                }
            });
        }
    }
    return recursiveRoots;
}
exports.getProjectAddonsRoots = getProjectAddonsRoots;
async function asyncGetPackageJSON(file) {
    const content = await asyncGetJSON(path.join(file, 'package.json'));
    return content;
}
exports.asyncGetPackageJSON = asyncGetPackageJSON;
async function asyncGetJSON(filePath) {
    try {
        const content = await (0, fs_provider_1.fsProvider)().readFile(filePath);
        if (content === null) {
            return {};
        }
        const result = JSON.parse(content);
        return result;
    }
    catch (e) {
        return {};
    }
}
exports.asyncGetJSON = asyncGetJSON;
function isEmberAddon(info) {
    return info.keywords && info.keywords.includes('ember-addon');
}
exports.isEmberAddon = isEmberAddon;
function addonVersion(info) {
    if (!isEmberAddon(info)) {
        return null;
    }
    return isEmberAddonV2(info) ? 2 : 1;
}
exports.addonVersion = addonVersion;
function isEmberAddonV2(info) {
    return info['ember-addon'] && info['ember-addon'].version === 2;
}
function isTemplatePath(filePath) {
    return filePath.endsWith('.hbs');
}
exports.isTemplatePath = isTemplatePath;
function isScriptPath(filePath) {
    if (isTestFile(filePath)) {
        return false;
    }
    return filePath.endsWith('.js') || filePath.endsWith('.ts') || filePath.endsWith('.gjs') || filePath.endsWith('.gts');
}
exports.isScriptPath = isScriptPath;
function normalizedPath(filePath) {
    if (filePath.includes('\\')) {
        return filePath.split('\\').join('/');
    }
    else {
        return filePath;
    }
}
exports.normalizedPath = normalizedPath;
function isStyleFile(filePath) {
    const ext = ['css', 'less', 'scss'];
    return ext.includes(filePath.split('.').pop());
}
exports.isStyleFile = isStyleFile;
function isTestFile(filePath) {
    return normalizedPath(filePath).includes('/tests/');
}
exports.isTestFile = isTestFile;
function hasAddonFolderInPath(name) {
    return name.includes(path.sep + 'addon' + path.sep) || name.includes(path.sep + 'addon-test-support' + path.sep);
}
exports.hasAddonFolderInPath = hasAddonFolderInPath;
async function getProjectAddonsInfo(root) {
    var _a, _b;
    const [projectAddonsRoots, projectInRepoAddonsRoots] = await Promise.all([getProjectAddonsRoots(root), getProjectInRepoAddonsRoots(root)]);
    const roots = [].concat(projectAddonsRoots, projectInRepoAddonsRoots).filter((pathItem) => typeof pathItem === 'string');
    for (const packagePath of roots) {
        const info = await asyncGetPackageJSON(packagePath);
        // logDebugInfo('info', info);
        const version = addonVersion(info);
        if (version === null) {
            continue;
        }
        if (version === 1) {
            const localProject = new base_project_1.BaseProject(packagePath);
            await Promise.all([
                listComponents(localProject),
                listRoutes(localProject),
                listHelpers(localProject),
                listModels(localProject),
                listTransforms(localProject),
                listServices(localProject),
                listModifiers(localProject),
            ]);
        }
        else if (version === 2) {
            const appExports = (_b = (_a = info === null || info === void 0 ? void 0 : info['ember-addon']) === null || _a === void 0 ? void 0 : _a['app-js']) !== null && _b !== void 0 ? _b : {};
            // https://github.com/embroider-build/embroider/blob/fe30c4c5a942e608c81082433940b530bfd6a7b2/SPEC.md#app-javascript
            if (typeof appExports !== 'string') {
                const localProject = new base_project_1.BaseProject(packagePath);
                localProject['classicMatcher'].setIgnores([]);
                localProject['podMatcher'].setIgnores([]);
                const appExportedPaths = Object.keys(appExports);
                appExportedPaths.forEach((el) => {
                    const entry = path.join(localProject.root, 'app', el);
                    const meta = localProject.matchPathToType(entry);
                    if (meta) {
                        const normalizedItem = (0, registry_api_1.normalizeMatchNaming)(meta);
                        (0, registry_api_1.addToRegistry)(normalizedItem.name, normalizedItem.type, [path.join(localProject.root, appExports[el])]);
                    }
                });
            }
            else {
                const entry = path.join(packagePath, appExports);
                const files = await safeWalkAsync(entry, {
                    directories: false,
                    globs: ['**/*.js', '**/*.ts', '**/*.hbs'],
                });
                const localProject = new base_project_1.BaseProject(entry);
                localProject['classicMatcher'].setIgnores([]);
                localProject['podMatcher'].setIgnores([]);
                files.forEach((el) => {
                    const entry = path.join(localProject.root, el);
                    const meta = localProject.matchPathToType(entry);
                    if (meta) {
                        const normalizedItem = (0, registry_api_1.normalizeMatchNaming)(meta);
                        (0, registry_api_1.addToRegistry)(normalizedItem.name, normalizedItem.type, [entry]);
                    }
                });
            }
        }
    }
}
exports.getProjectAddonsInfo = getProjectAddonsInfo;
async function listPodsComponents(project) {
    const podModulePrefix = (0, exports.podModulePrefixForRoot)(project.root);
    if (podModulePrefix === null) {
        return;
    }
    const entryPath = path.resolve(path.join(project.root, 'app', podModulePrefix, 'components'));
    const jsPaths = await safeWalkAsync(entryPath, {
        directories: false,
        globs: ['**/*.js', '**/*.ts', '**/*.hbs', '**/*.css', '**/*.less', '**/*.scss'],
    });
    jsPaths.forEach((filePath) => {
        const data = project.matchPathToType(filePath);
        if ((data === null || data === void 0 ? void 0 : data.type) === 'component') {
            (0, registry_api_1.addToRegistry)(data.name, data.type, [path.join(entryPath, filePath)]);
        }
    });
}
exports.listPodsComponents = listPodsComponents;
function builtinModifiers() {
    return [
        {
            kind: node_1.CompletionItemKind.Method,
            label: 'action',
            detail: 'modifier',
        },
    ];
}
exports.builtinModifiers = builtinModifiers;
async function hasNamespaceSupport(root) {
    const pack = await asyncGetPackageJSON(root);
    return hasDep(pack, 'ember-holy-futuristic-template-namespacing-batman');
}
exports.hasNamespaceSupport = hasNamespaceSupport;
async function listComponents(project) {
    // logDebugInfo('listComponents');
    const root = path.resolve(project.root);
    const scriptEntry = path.join(root, 'app', 'components');
    const templateEntry = path.join(root, 'app', 'templates', 'components');
    const addonComponents = path.join(root, 'addon', 'components');
    const addonTemplates = path.join(root, 'addon', 'templates', 'components');
    const [addonComponentsPaths, addonTemplatesPaths, jsPaths, hbsPaths] = await Promise.all([
        safeWalkAsync(addonComponents, {
            directories: false,
            globs: ['**/*.js', '**/*.ts', '**/*.hbs'],
        }),
        safeWalkAsync(addonTemplates, {
            directories: false,
            globs: ['**/*.js', '**/*.ts', '**/*.hbs'],
        }),
        safeWalkAsync(scriptEntry, {
            directories: false,
            globs: ['**/*.gjs', '**/*.gts', '**/*.js', '**/*.ts', '**/*.hbs', '**/*.css', '**/*.less', '**/*.scss'],
        }),
        safeWalkAsync(templateEntry, {
            directories: false,
            globs: ['**/*.hbs'],
        }),
    ]);
    addonComponentsPaths.forEach((p) => {
        var _a;
        const fsPath = path.join(addonComponents, p);
        const name = (_a = project.matchPathToType(fsPath)) === null || _a === void 0 ? void 0 : _a.name;
        if (name) {
            (0, registry_api_1.addToRegistry)(name, 'component', [fsPath]);
        }
    });
    addonTemplatesPaths.forEach((p) => {
        var _a;
        const fsPath = path.join(addonTemplates, p);
        const name = (_a = project.matchPathToType(fsPath)) === null || _a === void 0 ? void 0 : _a.name;
        if (name) {
            (0, registry_api_1.addToRegistry)(name, 'component', [fsPath]);
        }
    });
    jsPaths.forEach((p) => {
        var _a;
        const fsPath = path.join(scriptEntry, p);
        const name = (_a = project.matchPathToType(fsPath)) === null || _a === void 0 ? void 0 : _a.name;
        if (name) {
            (0, registry_api_1.addToRegistry)(name, 'component', [fsPath]);
        }
    });
    hbsPaths.forEach((p) => {
        var _a;
        const fsPath = path.join(templateEntry, p);
        const name = (_a = project.matchPathToType(fsPath)) === null || _a === void 0 ? void 0 : _a.name;
        if (name) {
            (0, registry_api_1.addToRegistry)(name, 'component', [fsPath]);
        }
    });
}
exports.listComponents = listComponents;
async function findRegistryItemsForProject(project, prefix, globs) {
    const entry = path.resolve(path.join(project.root, prefix));
    const paths = await safeWalkAsync(entry, {
        directories: false,
        globs,
    });
    paths.forEach((filePath) => {
        const fullPath = path.join(entry, filePath);
        const item = project.matchPathToType(fullPath);
        if (item) {
            const normalizedItem = (0, registry_api_1.normalizeMatchNaming)(item);
            (0, registry_api_1.addToRegistry)(normalizedItem.name, normalizedItem.type, [fullPath]);
        }
    });
}
async function findTestsForProject(project) {
    await findRegistryItemsForProject(project, 'tests', ['**/*.gjs', '**/*.gts', '**/*.js', '**/*.ts']);
}
exports.findTestsForProject = findTestsForProject;
async function findAppItemsForProject(project) {
    await findRegistryItemsForProject(project, 'app', ['**/*.gjs', '**/*.gts', '**/*.js', '**/*.ts', '**/*.css', '**/*.less', '**/*.sass', '**/*.hbs']);
}
exports.findAppItemsForProject = findAppItemsForProject;
async function findAddonItemsForProject(project) {
    await findRegistryItemsForProject(project, 'addon', ['**/*.js', '**/*.ts', '**/*.css', '**/*.less', '**/*.sass', '**/*.hbs']);
}
exports.findAddonItemsForProject = findAddonItemsForProject;
async function listCollection(project, prefix, collectionName, detail) {
    const entry = path.resolve(path.join(project.root, prefix, collectionName));
    const paths = await safeWalkAsync(entry, {
        directories: false,
        globs: ['**/*.js', '**/*.ts'],
    });
    paths.forEach((filePath) => {
        const fsPath = path.join(entry, filePath);
        const data = project.matchPathToType(fsPath);
        if (data && data.type === detail) {
            (0, registry_api_1.addToRegistry)(data.name, detail, [fsPath]);
        }
    });
}
async function listModifiers(project) {
    return listCollection(project, 'app', 'modifiers', 'modifier');
}
exports.listModifiers = listModifiers;
async function listModels(project) {
    return listCollection(project, 'app', 'models', 'model');
}
exports.listModels = listModels;
async function listServices(project) {
    return listCollection(project, 'app', 'services', 'service');
}
exports.listServices = listServices;
async function listHelpers(project) {
    return listCollection(project, 'app', 'helpers', 'helper');
}
exports.listHelpers = listHelpers;
async function listTransforms(project) {
    return listCollection(project, 'app', 'transforms', 'transform');
}
exports.listTransforms = listTransforms;
async function listRoutes(project) {
    const root = path.resolve(project.root);
    const scriptEntry = path.join(root, 'app', 'routes');
    const templateEntry = path.join(root, 'app', 'templates');
    const controllersEntry = path.join(root, 'app', 'controllers');
    const paths = await safeWalkAsync(scriptEntry, {
        directories: false,
        globs: ['**/*.js', '**/*.ts'],
    });
    const templatePaths = (await safeWalkAsync(templateEntry, {
        directories: false,
        globs: ['**/*.hbs'],
    })).filter((name) => {
        const skipEndings = ['-loading', '-error', '/loading', '/error'];
        return !name.startsWith('components/') && skipEndings.filter((ending) => name.endsWith(ending + '.hbs')).length === 0;
    });
    const controllers = await safeWalkAsync(controllersEntry, {
        directories: false,
        globs: ['**/*.js', '**/*.ts'],
    });
    templatePaths.forEach((filePath) => {
        const label = filePath.replace(path.extname(filePath), '').replace(/\//g, '.');
        (0, registry_api_1.addToRegistry)(label, 'routePath', [path.join(templateEntry, filePath)]);
    });
    paths.forEach((filePath) => {
        const label = filePath.replace(path.extname(filePath), '').replace(/\//g, '.');
        (0, registry_api_1.addToRegistry)(label, 'routePath', [path.join(scriptEntry, filePath)]);
        return {
            kind: node_1.CompletionItemKind.File,
            label,
            detail: 'route',
        };
    });
    controllers.forEach((filePath) => {
        const label = filePath.replace(path.extname(filePath), '').replace(/\//g, '.');
        (0, registry_api_1.addToRegistry)(label, 'routePath', [path.join(controllersEntry, filePath)]);
    });
}
exports.listRoutes = listRoutes;
//# sourceMappingURL=layout-helpers.js.map