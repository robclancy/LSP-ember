"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addToRegistry = exports.existsInRegistry = exports.getRegistryForRoot = exports.getRegistryForRoots = exports.removeFromRegistry = exports.normalizeMatchNaming = exports.canCollectTemplateTokens = exports.enableTemplateTokensCollection = exports.disableTemplateTokensCollection = exports.getGlobalRegistry = void 0;
const usages_api_1 = require("./usages-api");
const layout_helpers_1 = require("./layout-helpers");
const path = require("path");
const logger_1 = require("./logger");
function getGlobalRegistry() {
    return GLOBAL_REGISTRY;
}
exports.getGlobalRegistry = getGlobalRegistry;
let _templateTokensCollectionEnabled = true;
function disableTemplateTokensCollection() {
    (0, logger_1.logDebugInfo)('disable:TemplateTokensCollection');
    _templateTokensCollectionEnabled = false;
}
exports.disableTemplateTokensCollection = disableTemplateTokensCollection;
function enableTemplateTokensCollection() {
    (0, logger_1.logDebugInfo)('enable:TemplateTokensCollection');
    _templateTokensCollectionEnabled = true;
}
exports.enableTemplateTokensCollection = enableTemplateTokensCollection;
function canCollectTemplateTokens() {
    return _templateTokensCollectionEnabled;
}
exports.canCollectTemplateTokens = canCollectTemplateTokens;
const GLOBAL_REGISTRY = {
    transform: new Map(),
    helper: new Map(),
    component: new Map(),
    routePath: new Map(),
    model: new Map(),
    service: new Map(),
    modifier: new Map(),
};
function normalizeMatchNaming(item) {
    if (['template', 'controller', 'route'].includes(item.type)) {
        return {
            type: 'routePath',
            name: (0, layout_helpers_1.normalizeRoutePath)(item.name),
        };
    }
    return item;
}
exports.normalizeMatchNaming = normalizeMatchNaming;
function removeFromRegistry(normalizedName, kind, files) {
    if (!(kind in GLOBAL_REGISTRY)) {
        return;
    }
    if (!GLOBAL_REGISTRY[kind].has(normalizedName)) {
        return;
    }
    if (GLOBAL_REGISTRY[kind].has(normalizedName)) {
        const regItem = GLOBAL_REGISTRY[kind].get(normalizedName);
        if (regItem) {
            files.forEach((file) => {
                regItem.delete(file);
                if ((0, layout_helpers_1.isTemplatePath)(file) && canCollectTemplateTokens()) {
                    (0, usages_api_1.updateTemplateTokens)(kind, normalizedName, null);
                }
            });
            if (regItem.size === 0) {
                GLOBAL_REGISTRY[kind].delete(normalizedName);
            }
        }
    }
}
exports.removeFromRegistry = removeFromRegistry;
function getRegistryForRoots(rawRoots) {
    return _getRegistryForRoots(rawRoots);
}
exports.getRegistryForRoots = getRegistryForRoots;
function _getRegistryForRoots(rawRoots) {
    const roots = rawRoots.map((rawRoot) => path.resolve(rawRoot));
    const lowRoot = roots.map((root) => root.toLowerCase());
    const registryForRoot = {
        transform: {},
        helper: {},
        component: {},
        routePath: {},
        model: {},
        service: {},
        modifier: {},
    };
    const registry = getGlobalRegistry();
    Object.keys(registry).forEach((key) => {
        registryForRoot[key] = {};
        const data = {};
        let hasData = false;
        Object.defineProperty(registryForRoot, key, {
            enumerable: true,
            get() {
                if (hasData === false) {
                    for (const [itemName, paths] of registry[key].entries()) {
                        const items = [];
                        paths.forEach((normalizedPath) => {
                            const kindPath = normalizedPath.toLowerCase();
                            if (lowRoot.some((lowRoot) => {
                                return (0, layout_helpers_1.isRootStartingWithFilePath)(lowRoot, kindPath);
                            })) {
                                items.push(normalizedPath);
                            }
                        });
                        if (items.length) {
                            data[itemName] = items;
                        }
                    }
                    hasData = true;
                }
                return data;
            },
        });
    });
    return registryForRoot;
}
function getRegistryForRoot(rawRoot) {
    return _getRegistryForRoots([rawRoot]);
}
exports.getRegistryForRoot = getRegistryForRoot;
function existsInRegistry(name, kind, file) {
    var _a;
    const regItem = GLOBAL_REGISTRY[kind];
    if (!regItem) {
        return false;
    }
    if (!regItem.has(name)) {
        return false;
    }
    return (_a = regItem.get(name)) === null || _a === void 0 ? void 0 : _a.has(path.resolve(file));
}
exports.existsInRegistry = existsInRegistry;
function addToRegistry(normalizedName, kind, files) {
    if (!(kind in GLOBAL_REGISTRY)) {
        return;
    }
    if (!GLOBAL_REGISTRY[kind].has(normalizedName)) {
        GLOBAL_REGISTRY[kind].set(normalizedName, new Set());
    }
    if (GLOBAL_REGISTRY[kind].has(normalizedName)) {
        const regItem = GLOBAL_REGISTRY[kind].get(normalizedName);
        if (regItem) {
            files.forEach((rawFile) => {
                const file = path.resolve(rawFile);
                regItem.add(file);
                if (canCollectTemplateTokens() && (kind === 'component' || kind === 'routePath') && (0, layout_helpers_1.isTemplatePath)(file)) {
                    (0, usages_api_1.updateTemplateTokens)(kind, normalizedName, file);
                }
            });
        }
    }
}
exports.addToRegistry = addToRegistry;
//# sourceMappingURL=registry-api.js.map