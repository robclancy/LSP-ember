"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsyncFsProvider = exports.fsProvider = exports.setFSImplementation = void 0;
const fs = require("fs");
const vscode_uri_1 = require("vscode-uri");
const fs_utils_1 = require("./utils/fs-utils");
const path = require("path");
let currentFSImplementation;
function setFSImplementation(fs) {
    currentFSImplementation = fs;
}
exports.setFSImplementation = setFSImplementation;
function fsProvider() {
    if (!currentFSImplementation) {
        setFSImplementation(new FSProvider());
    }
    return currentFSImplementation;
}
exports.fsProvider = fsProvider;
class FSProvider {
    constructor() {
        this.createWriteStream = this.createWriteStream.bind(this);
        this.exists = this.exists.bind(this);
        this.readDirectory = this.readDirectory.bind(this);
        this.readFile = this.readFile.bind(this);
        this.realpathSync = this.realpathSync.bind(this);
        this.stat = this.stat.bind(this);
    }
    // expected VSCode api, replacement of existsSync
    get hasRealFsAccess() {
        return true;
    }
    async exists(uri) {
        const entry = vscode_uri_1.URI.isUri(uri) ? vscode_uri_1.URI.parse(uri).fsPath : uri;
        try {
            await fs.statSync(entry);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    async stat(uri) {
        const entry = vscode_uri_1.URI.isUri(uri) ? vscode_uri_1.URI.parse(uri).fsPath : uri;
        return fs.statSync(entry);
    }
    // expected VSCode api, replacement of readFileSync
    async readFile(uri) {
        const entry = vscode_uri_1.URI.isUri(uri) ? vscode_uri_1.URI.parse(uri).fsPath : uri;
        try {
            const item = fs.readFileSync(entry, null);
            return item.toString('utf8');
        }
        catch (e) {
            return null;
        }
        // need this lines to debug slowness issues
        // await new Promise((resolve) => setTimeout(resolve, 200));
    }
    // logger api
    createWriteStream(filePath, flags) {
        return fs.createWriteStream(filePath, flags);
    }
    async readDirectory(filePath) {
        try {
            const files = fs.readdirSync(filePath).map((el) => {
                return el;
            });
            return files.map((fName) => {
                let fType = fs_utils_1.FileType.Unknown;
                try {
                    fType = (0, fs_utils_1.fileTypeFromFsStat)(fs.statSync(path.join(filePath, '/', fName)));
                }
                catch (e) {
                    // EOL;
                }
                return [fName, fType];
            });
        }
        catch (e) {
            throw null;
        }
    }
    realpathSync(filePath, options) {
        if (!this.hasRealFsAccess) {
            throw new Error('RealpathSync supported only in real FS environments');
        }
        return fs.realpathSync(filePath, options);
    }
}
exports.default = FSProvider;
class AsyncFsProvider extends FSProvider {
    constructor(server) {
        super();
        this.server = server;
    }
    get hasRealFsAccess() {
        return false;
    }
    getGetUri(uri) {
        const entry = vscode_uri_1.URI.file(uri);
        return entry;
    }
    sendCommand(command, ...options) {
        return this.server.sendCommand(command, ...options);
    }
    async stat(uri) {
        const entry = this.getGetUri(uri);
        const data = (await this.sendCommand('els.fs.stat', entry));
        if (data === null) {
            throw null;
        }
        return (0, fs_utils_1.convertToFsStat)(data);
    }
    async readFile(uri) {
        const entry = this.getGetUri(uri);
        const result = await this.sendCommand('els.fs.readFile', entry);
        if (typeof result !== 'string') {
            return null;
        }
        return result;
    }
    async readDirectory(rawUri) {
        let uri = rawUri;
        if (rawUri.endsWith('/') || rawUri.endsWith('\\')) {
            uri = uri.slice(0, -1);
        }
        const entry = this.getGetUri(uri);
        const data = (await this.sendCommand('els.fs.readDirectory', entry));
        if (data === null) {
            throw null;
        }
        return data;
    }
    async exists(uri) {
        const entry = this.getGetUri(uri);
        const result = await this.sendCommand('els.fs.stat', entry);
        if (result === null) {
            return false;
        }
        else {
            return true;
        }
    }
}
exports.AsyncFsProvider = AsyncFsProvider;
//# sourceMappingURL=fs-provider.js.map