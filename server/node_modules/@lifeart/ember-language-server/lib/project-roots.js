'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const logger_1 = require("./utils/logger");
const vscode_uri_1 = require("vscode-uri");
const layout_helpers_1 = require("./utils/layout-helpers");
const project_1 = require("./project");
const addon_api_1 = require("./utils/addon-api");
class ProjectRoots {
    constructor(server) {
        this.server = server;
        this.projects = new Map();
        this.localAddons = [];
        this.ignoredProjects = [];
    }
    async reloadProjects() {
        const queue = Array.from(this.projects).map(([root]) => {
            return this.reloadProject(root);
        });
        await Promise.all(queue);
    }
    isIgnoredProject(name) {
        if (typeof name === 'undefined') {
            return false;
        }
        if (this.ignoredProjects.includes(name)) {
            return true;
        }
        const hasReverseIgnore = this.ignoredProjects.filter((el) => el.startsWith('!'));
        if (!hasReverseIgnore.length) {
            return false;
        }
        const allowedProjectName = `!${name}`;
        return !hasReverseIgnore.includes(allowedProjectName);
    }
    async reloadProject(projectRoot) {
        await this.removeProject(projectRoot);
        await this.onProjectAdd(projectRoot);
    }
    async removeProject(projectRoot) {
        const project = this.projectForPath(projectRoot);
        if (project) {
            await project.unload();
        }
        this.projects.delete(projectRoot);
    }
    async setLocalAddons(paths) {
        for (const element of paths) {
            const addonPath = path.resolve(element);
            const hasFile = await this.server.fs.exists(addonPath);
            const isAddonRoot = await (0, layout_helpers_1.isELSAddonRoot)(addonPath);
            if (hasFile && isAddonRoot) {
                if (!this.localAddons.includes(addonPath)) {
                    this.localAddons.push(addonPath);
                }
            }
        }
    }
    setIgnoredProjects(ignoredProjects) {
        this.ignoredProjects = ignoredProjects;
    }
    async findProjectsInsideRoot(workspaceRoot) {
        const roots = await (0, layout_helpers_1.safeWalkAsync)(workspaceRoot, {
            directories: false,
            globs: ['**/ember-cli-build.js', '**/package.json'],
            ignore: ['**/.git/**', '**/bower_components/**', '**/dist/**', '**/node_modules/**', '**/tmp/**'],
        });
        for (const rootPath of roots) {
            const filePath = path.join(workspaceRoot, rootPath);
            const fullPath = path.dirname(filePath);
            if (filePath.endsWith('package.json')) {
                try {
                    if (await (0, layout_helpers_1.isGlimmerXProject)(fullPath)) {
                        await this.onProjectAdd(fullPath);
                    }
                }
                catch (e) {
                    (0, logger_1.logError)(e);
                }
            }
            else {
                await this.onProjectAdd(fullPath);
            }
        }
    }
    async initialize(workspaceRoot) {
        this.workspaceRoot = workspaceRoot;
        await this.findProjectsInsideRoot(this.workspaceRoot);
    }
    // @todo figure out better solution
    _fixRemoveFSArtifacts(fPath) {
        return fPath.replace('/\\', '/');
    }
    async onProjectAdd(rawPath) {
        const projectPath = this._fixRemoveFSArtifacts(path.resolve(vscode_uri_1.URI.parse(rawPath).fsPath));
        if (this.projects.has(projectPath)) {
            const project = this.projects.get(projectPath);
            return {
                initIssues: project.initIssues,
                providers: project.providers,
                addonsMeta: project.addonsMeta,
                name: project.name,
                registry: project.registry,
            };
        }
        try {
            const info = await (0, layout_helpers_1.asyncGetPackageJSON)(projectPath);
            if (!info.name) {
                (0, logger_1.logInfo)(`Unable to get project name from package.json at ${projectPath}`);
            }
            if (this.isIgnoredProject(info.name)) {
                (0, logger_1.logInfo)('--------------------');
                (0, logger_1.logInfo)(`Skipping "${info.name}" initialization, because it's marked as ignored in uELS settings.`);
                (0, logger_1.logInfo)(`Skipped path: ${projectPath}`);
                (0, logger_1.logInfo)('If you use this addon/engine/project in host app, not marked as ignored, all LS features will work for it.');
                (0, logger_1.logInfo)('--------------------');
                return {
                    initIssues: [`Unable to create project "${info.name}", because it ignored according to config: [${this.ignoredProjects.join(',')}]`],
                    providers: (0, addon_api_1.emptyProjectProviders)(),
                    addonsMeta: [],
                    name: info.name,
                    registry: {},
                };
            }
            const project = new project_1.Project(projectPath, this.localAddons, info);
            await project.initialize(this.server);
            this.projects.set(projectPath, project);
            (0, logger_1.logInfo)(`Ember CLI project added at ${projectPath}`);
            await project.init(this.server);
            return {
                initIssues: project.initIssues,
                providers: project.providers,
                addonsMeta: project.addonsMeta,
                name: project.name,
                registry: project.registry,
            };
        }
        catch (e) {
            (0, logger_1.logError)(e);
            return {
                initIssues: [e.toString(), e.stack],
                providers: (0, addon_api_1.emptyProjectProviders)(),
                addonsMeta: [],
                name: `[${projectPath}]`,
                registry: {},
            };
        }
    }
    projectForUri(uri) {
        const filePath = vscode_uri_1.URI.parse(uri).fsPath;
        if (!filePath) {
            return;
        }
        return this.projectForPath(filePath);
    }
    projectForPath(rawPath) {
        const filePath = path.resolve(rawPath).toLowerCase();
        /*
          to fix C:\\Users\\lifeart\\AppData\\Local\\Temp\\tmp-30396kTX1RpAxCCyc
          and c:\\Users\\lifeart\\AppData\\Local\\Temp\\tmp-30396kTX1RpAxCCyc\\app\\components\\hello.hbs
          we need to lowercase items (because of capital C);
        */
        const rootMap = {};
        const projectRoots = (Array.from(this.projects.keys()) || [])
            .map((root) => {
            var _a;
            const projectName = (_a = this.projects.get(root)) === null || _a === void 0 ? void 0 : _a.name;
            if (projectName && this.ignoredProjects.includes(projectName)) {
                return;
            }
            const lowerName = root.toLowerCase();
            rootMap[lowerName] = root;
            return lowerName;
        })
            .filter((item) => item !== undefined);
        const rawRoot = projectRoots
            .filter((root) => (0, layout_helpers_1.isRootStartingWithFilePath)(root, filePath))
            .reduce((a, b) => {
            return a.length > b.length ? a : b;
        }, '');
        const root = rootMap[rawRoot] || '';
        if (root === '') {
            /* this is case for filePath from in-repo-addon, located on same level with application itself
              like:
              ====================
                my-app
                  package.json {
                    ember-addon: {
                      paths: ['../in-repo-addon']
                    }
                  }
                in-repo-addon
              ====================
              it's safe to do, because root will be non empty if addon already registered as Project
            */
            const fistSubRoot = Array.from(this.projects.values())
                .filter((project) => project.name && !this.ignoredProjects.includes(project.name))
                .find((project) => project.roots.some((subRoot) => (0, layout_helpers_1.isRootStartingWithFilePath)(subRoot.toLocaleLowerCase(), filePath)));
            if (fistSubRoot) {
                return fistSubRoot;
            }
            else {
                return undefined;
            }
        }
        return this.projects.get(root);
    }
}
exports.default = ProjectRoots;
//# sourceMappingURL=project-roots.js.map