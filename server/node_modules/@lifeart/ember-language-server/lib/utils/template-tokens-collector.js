"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractTokensFromTemplate = exports.getTemplateBlocks = void 0;
const syntax_1 = require("@glimmer/syntax");
const normalizers_1 = require("./normalizers");
function tokensFromType(node, scopedTokens) {
    const tokensMap = {
        BlockStatement: (node) => {
            if (node.path.type === 'PathExpression') {
                if (node.path.head.type === 'AtHead' || node.path.head.type === 'ThisHead') {
                    return;
                }
                if (node.path.head.name === 'component') {
                    if (node.params.length && node.params[0].type === 'StringLiteral') {
                        const possibleToken = node.params[0].value;
                        if (!scopedTokens.includes(possibleToken)) {
                            return possibleToken;
                        }
                    }
                }
            }
            return;
        },
        MustacheStatement: (node) => {
            if (node.path.type === 'PathExpression') {
                if (node.path.head.type === 'AtHead' || node.path.head.type === 'ThisHead') {
                    return;
                }
                if (node.path.head.name === 'component') {
                    if (node.params.length && node.params[0].type === 'StringLiteral') {
                        const possibleToken = node.params[0].value;
                        if (!scopedTokens.includes(possibleToken)) {
                            return possibleToken;
                        }
                    }
                }
            }
            return;
        },
        SubExpression: (node) => {
            if (node.path.type === 'PathExpression') {
                if (node.path.head.type === 'AtHead' || node.path.head.type === 'ThisHead') {
                    return;
                }
                if (node.path.head.name === 'component') {
                    if (node.params.length && node.params[0].type === 'StringLiteral') {
                        const possibleToken = node.params[0].value;
                        if (!scopedTokens.includes(possibleToken)) {
                            return possibleToken;
                        }
                    }
                }
            }
            return;
        },
        PathExpression: (node) => {
            if (node.head.type === 'AtHead' || node.head.type === 'ThisHead') {
                return;
            }
            const possibleToken = node.head.name;
            if (!scopedTokens.includes(possibleToken)) {
                return possibleToken;
            }
        },
        ElementNode: ({ tag }) => {
            const char = tag.charAt(0);
            if (char !== char.toUpperCase() || char === ':') {
                return;
            }
            if (scopedTokens.includes(tag)) {
                return;
            }
            return tag;
        },
    };
    if (node.type in tokensMap) {
        return tokensMap[node.type](node);
    }
}
function addTokens(tokensSet, node, scopedTokens, nativeTokens = []) {
    const maybeTokens = tokensFromType(node, scopedTokens);
    (Array.isArray(maybeTokens) ? maybeTokens : [maybeTokens]).forEach((maybeToken) => {
        if (maybeToken !== undefined && !nativeTokens.includes(maybeToken) && !maybeToken.startsWith('@')) {
            tokensSet.add(maybeToken);
        }
    });
}
function getTemplateBlocks(html) {
    const ast = (0, syntax_1.preprocess)(html);
    const tokensSet = new Set();
    const defaultBlocks = ['inverse', 'else'];
    (0, syntax_1.traverse)(ast, {
        MustacheStatement: {
            enter(node) {
                const p = node.path;
                if (p && p.type === 'PathExpression' && p.original === 'yield' && p.head.type !== 'AtHead' && p.head.type !== 'ThisHead') {
                    const to = node.hash.pairs.find((p) => {
                        return p.key === 'to';
                    });
                    if (to && to.value && to.value.type === 'StringLiteral') {
                        if (!defaultBlocks.includes(to.value.original)) {
                            tokensSet.add(to.value.original);
                        }
                    }
                }
            },
        },
    });
    return Array.from(tokensSet).map((el) => (0, normalizers_1.normalizeToNamedBlockName)(el));
}
exports.getTemplateBlocks = getTemplateBlocks;
function getTemplateTokens(ast, nativeTokens) {
    const tokensSet = new Set();
    const scopedTokens = [];
    (0, syntax_1.traverse)(ast, {
        Block: {
            enter({ blockParams }) {
                blockParams.forEach((param) => {
                    scopedTokens.push(param);
                });
            },
            exit({ blockParams }) {
                blockParams.forEach(() => {
                    scopedTokens.pop();
                });
            },
        },
        ElementNode: {
            enter(node) {
                node.blockParams.forEach((param) => {
                    scopedTokens.push(param);
                });
                addTokens(tokensSet, node, scopedTokens);
            },
            exit({ blockParams }) {
                blockParams.forEach(() => {
                    scopedTokens.pop();
                });
            },
        },
        All(node) {
            addTokens(tokensSet, node, scopedTokens, nativeTokens);
        },
    });
    return Array.from(tokensSet).map((el) => (0, normalizers_1.normalizeToClassicComponent)(el));
}
function extractTokensFromTemplate(template) {
    const ignored = [
        'if',
        'hash',
        'array',
        'yield',
        'outlet',
        'component',
        'else',
        'unless',
        'let',
        'each',
        'each-in',
        'in-element',
        'has-block',
        'has-block-params',
        'unbound',
        'input',
        'on',
        'fn',
        'debugger',
        'console',
    ];
    return getTemplateTokens(template, ignored);
}
exports.extractTokensFromTemplate = extractTokensFromTemplate;
//# sourceMappingURL=template-tokens-collector.js.map