"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("vscode-languageserver/node");
const glimmer_script_1 = require("../utils/glimmer-script");
const ember_meta_explorer_1 = require("ember-meta-explorer");
const glimmer_template_1 = require("../utils/glimmer-template");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
// @ts-expect-error es module import
const camelCase = require("lodash/camelCase");
const path = require("path");
class GlimmerScriptCompletionProvider {
    constructor(server) {
        this.server = server;
    }
    async provideCompletions(params) {
        const document = this.server.documents.get(params.textDocument.uri);
        if (!document) {
            return [];
        }
        const rawContent = document.getText();
        const ranges = (0, glimmer_script_1.getFileRanges)(rawContent);
        let rangeWalker = new glimmer_script_1.RangeWalker(ranges);
        // strip not needed scopes example
        rangeWalker = rangeWalker.subtract(rangeWalker.hbsInlineComments(true));
        rangeWalker = rangeWalker.subtract(rangeWalker.hbsComments(true));
        rangeWalker = rangeWalker.subtract(rangeWalker.htmlComments(true));
        const templates = rangeWalker.templates(true);
        const cleanScriptWalker = rangeWalker.subtract(templates, true);
        const templateForPosition = (0, glimmer_script_1.documentPartForPosition)(templates, params.position);
        if (templateForPosition) {
            const results = [];
            let scopes = [];
            try {
                const ast = (0, ember_meta_explorer_1.parseScriptFile)(cleanScriptWalker.content, {
                    sourceType: 'module',
                });
                const placeholder = (0, glimmer_script_1.getPlaceholderPathFromAst)(ast, templateForPosition.key);
                if (!placeholder) {
                    return [];
                }
                scopes = (0, glimmer_script_1.getScope)(placeholder.scope);
            }
            catch (e) {
                // oops
            }
            scopes.forEach((name) => {
                results.push({
                    label: name,
                });
            });
            const synthDoc = vscode_languageserver_textdocument_1.TextDocument.create(document.uri, 'handlebars', document.version, templateForPosition.absoluteContent);
            const info = (0, glimmer_template_1.getFocusPath)(synthDoc, params.position);
            if (!info) {
                return results;
            }
            const project = this.server.projectRoots.projectForUri(params.textDocument.uri);
            if (!project) {
                return results;
            }
            const legacyResults = await this.server.templateCompletionProvider.provideCompletionsForFocusPath(info, params.textDocument, params.position, project);
            legacyResults.forEach((result) => {
                results.push(this.transformLegacyResult(result, scopes, params.position, info.focusPath, project));
            });
            return results;
            // do logic to get more meta from js scope for template position
            // here we need glimmer logic to collect all available tokens from scope for autocomplete
        }
        else {
            return [];
        }
    }
    transformLegacyResult(result, scopes, position, focusPath, project) {
        var _a, _b;
        if (!((_b = (_a = result.data) === null || _a === void 0 ? void 0 : _a.files) === null || _b === void 0 ? void 0 : _b.length)) {
            return result;
        }
        const files = result.data.files;
        const meta = files.map((f) => {
            return project.matchPathToType(f);
        });
        const appScript = meta.find((e) => e.kind === 'script' && e.scope === 'application');
        const appTemplate = meta.find((e) => e.kind === 'template' && e.scope === 'application');
        const addonScript = meta.find((e) => e.kind === 'script' && e.scope === 'addon');
        const addonTemplate = meta.find((e) => e.kind === 'template' && e.scope === 'addon');
        const fileRef = appScript || appTemplate || addonScript || addonTemplate;
        if (!fileRef) {
            return result;
        }
        const file = files[meta.indexOf(fileRef)];
        result.data.resolvedFile = file;
        const fileProject = project.addonForFile(file);
        let p = '';
        if (fileProject) {
            p = `${fileProject.name}/${fileRef.type}s/${fileRef.name}`;
        }
        else {
            p = path.relative(project.root, file).split('\\').join('/').replace('app', project.name);
            p = p.replace('.js', '').replace('.ts', '').replace('.gjs', '').replace('.gts', '').replace('.hbs', '');
        }
        if (p.endsWith('/index')) {
            p = p.replace('/index', '');
        }
        let name = result.label;
        if (name.charAt(0).toUpperCase() === name.charAt(0)) {
            name = name.includes('::') ? name.split('::').pop() : name;
            if (name.includes('$')) {
                name = name.split('$').pop();
            }
            // component
        }
        else {
            // helper, modifier
            name = camelCase(name);
        }
        if (!name) {
            return result;
        }
        if (scopes.includes(name)) {
            return result;
        }
        const importPath = p;
        result.insertTextFormat = node_1.InsertTextFormat.Snippet;
        result.detail = `(${result.label}) ${result.detail || ''}`.trim();
        result.documentation = `
      import ${name} from '${importPath}';

      ${result.documentation || ''}
    `.trim();
        result.label = name;
        result.additionalTextEdits = [node_1.TextEdit.insert(node_1.Position.create(0, 0), `import ${name} from '${importPath}';\n`)];
        const loc = focusPath.node.loc.toJSON();
        const startPosition = node_1.Position.create(position.line, loc.start.column);
        let prefix = ``;
        const source = focusPath.sourceForNode();
        if (source === null || source === void 0 ? void 0 : source.startsWith('{{')) {
            prefix = '{{';
        }
        else if (source === null || source === void 0 ? void 0 : source.startsWith('(')) {
            prefix = '(';
        }
        else if (source === null || source === void 0 ? void 0 : source.startsWith('<')) {
            prefix = '<';
        }
        else if (source === null || source === void 0 ? void 0 : source.startsWith('@')) {
            prefix = '@';
        }
        const txt = `${prefix}${name}`;
        const endPosition = node_1.Position.create(position.line, loc.start.column + txt.length);
        result.textEdit = node_1.TextEdit.replace({
            start: startPosition,
            end: endPosition,
        }, txt);
        return result;
    }
}
exports.default = GlimmerScriptCompletionProvider;
//# sourceMappingURL=glimmer-script-completion-provider.js.map