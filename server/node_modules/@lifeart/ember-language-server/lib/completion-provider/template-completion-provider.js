"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fuzzaldrin_1 = require("fuzzaldrin");
const addon_api_1 = require("./../utils/addon-api");
const syntax_1 = require("@glimmer/syntax");
const file_extension_1 = require("../utils/file-extension");
const logger_1 = require("../utils/logger");
const glimmer_template_1 = require("../utils/glimmer-template");
class TemplateCompletionProvider {
    constructor(server) {
        this.server = server;
    }
    getTextForGuessing(originalText, offset, PLACEHOLDER) {
        // logDebugInfo('getTextForGuessing', originalText, offset, PLACEHOLDER);
        return (0, glimmer_template_1.getTextForGuessing)(originalText, offset, PLACEHOLDER);
    }
    getRoots(doc) {
        const project = this.server.projectRoots.projectForUri(doc.uri);
        const document = this.server.documents.get(doc.uri);
        return {
            project,
            document,
        };
    }
    getAST(textContent) {
        return (0, syntax_1.preprocess)(textContent);
    }
    createFocusPath(ast, position, validText) {
        return (0, glimmer_template_1.createFocusPath)(ast, position, validText);
    }
    getFocusPath(document, position, placeholder = glimmer_template_1.PLACEHOLDER) {
        return (0, glimmer_template_1.getFocusPath)(document, position, placeholder);
    }
    async provideCompletionsForFocusPath(results, textDocument, position, project) {
        const focusPath = results.focusPath;
        const originalText = results.originalText;
        const normalPlaceholder = results.normalPlaceholder;
        const root = project.root;
        const completions = await (0, addon_api_1.queryELSAddonsAPIChain)(project.builtinProviders.completionProviders, root, {
            focusPath,
            textDocument,
            position,
            results: [],
            server: this.server,
            type: 'template',
            originalText,
        });
        const addonResults = await (0, addon_api_1.queryELSAddonsAPIChain)(project.providers.completionProviders, root, {
            focusPath,
            textDocument,
            position,
            results: completions,
            server: this.server,
            type: 'template',
        });
        const textPrefix = getTextPrefix(focusPath, normalPlaceholder);
        const alignedPosition = { ...position };
        const endCharacterPosition = position.character;
        if (textPrefix.length) {
            // eslint-disable-next-line
            alignedPosition.character -= textPrefix.length;
        }
        return (0, fuzzaldrin_1.filter)(addonResults, textPrefix, {
            key: 'label',
            maxResults: 40,
        }).map((rawEl) => {
            const el = Object.assign({}, rawEl);
            if (el.textEdit) {
                return el;
            }
            const endPosition = {
                line: alignedPosition.line,
                character: endCharacterPosition,
            };
            const shouldFixContent = normalPlaceholder.includes('}}{{');
            el.textEdit = {
                newText: shouldFixContent ? normalPlaceholder.split(glimmer_template_1.PLACEHOLDER).join(el.label).replace('}}{{', '}}\n  \n{{') : el.label,
                range: {
                    start: alignedPosition,
                    end: endPosition,
                },
            };
            return el;
        });
    }
    async provideCompletions(params) {
        (0, logger_1.logDebugInfo)('template:provideCompletions');
        const ext = (0, file_extension_1.getExtension)(params.textDocument);
        // @to-do cleanup this creepy stuff (streamline autocomplete stuff);
        const extToHandle = glimmer_template_1.extensionsToProvideTemplateCompletions.filter((e) => e !== '.gts' && e !== '.gjs');
        if (ext !== null && !extToHandle.includes(ext)) {
            (0, logger_1.logDebugInfo)('template:provideCompletions:unsupportedExtension', ext);
            return [];
        }
        const position = Object.freeze({ ...params.position });
        const { project, document } = this.getRoots(params.textDocument);
        if (!project || !document) {
            (0, logger_1.logInfo)(`No project for file: ${params.textDocument.uri}`);
            return [];
        }
        const results = this.getFocusPath(document, position, glimmer_template_1.PLACEHOLDER);
        if (!results) {
            return [];
        }
        return this.provideCompletionsForFocusPath(results, params.textDocument, position, project);
    }
}
exports.default = TemplateCompletionProvider;
function getTextPrefix(astPath, normalPlaceholder) {
    let node = astPath.node;
    if (node === undefined) {
        return normalPlaceholder;
    }
    // handle block params autocomplete case
    if (node.type === 'ElementNode' || node.type === 'BlockStatement') {
        const meta = astPath.metaForType('handlebars');
        const maybeBlockDefenition = meta && meta.maybeBlockParamDefinition;
        if (maybeBlockDefenition) {
            node = maybeBlockDefenition;
        }
    }
    let target = '';
    if ('original' in node) {
        target = String(node.original);
    }
    else if ('tag' in node) {
        target = node.tag;
    }
    else if ('name' in node) {
        target = String(node.name);
    }
    else if ('chars' in node) {
        target = node.chars;
    }
    return target.replace(normalPlaceholder, '').replace(glimmer_template_1.PLACEHOLDER, '');
}
//# sourceMappingURL=template-completion-provider.js.map