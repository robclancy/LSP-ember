"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLocalScope = exports.sourceForNode = exports.nodeLoc = exports.isBlockParamDefinition = exports.maybeBlockParamDefinition = exports.BlockParamDefinition = exports.focusedBlockParamName = exports.isLocalScopedPathExpression = exports.maybeComponentNameForPath = void 0;
const estree_utils_1 = require("./estree-utils");
const normalizers_1 = require("./utils/normalizers");
const reLines = /(.*?(?:\r\n?|\n|$))/gm;
function maybePathDeclaration(astPath) {
    if (isLocalScopedPathExpression(astPath)) {
        const scope = getLocalScope(astPath);
        const pathName = getLocalPathName(astPath.node);
        if (pathName) {
            const declaration = scope.find(({ name }) => name === pathName);
            if (!declaration) {
                return;
            }
            return declaration.path;
        }
    }
}
function maybeComponentNameForPath(astPath) {
    const declaration = maybePathDeclaration(astPath);
    if (declaration && declaration.node.type === 'ElementNode') {
        return declaration.node.tag;
    }
}
exports.maybeComponentNameForPath = maybeComponentNameForPath;
function getLocalPathName(node) {
    if (!node || node.type !== 'PathExpression' || !node.parts.length) {
        return undefined;
    }
    const pathName = node.parts[0];
    if (pathName === 'this') {
        return undefined;
    }
    return pathName;
}
function isLocalScopedPathExpression(astPath) {
    const pathName = getLocalPathName(astPath.node);
    if (!pathName) {
        return false;
    }
    const scope = getLocalScope(astPath);
    const declarations = scope.filter(({ name }) => name === pathName);
    if (declarations.length) {
        return true;
    }
    else {
        return false;
    }
}
exports.isLocalScopedPathExpression = isLocalScopedPathExpression;
function focusedBlockParamName(content, position) {
    const source = content.match(reLines);
    const focusedLine = source[position.line - 1];
    let paramName = '';
    if (typeof focusedLine !== 'string') {
        return paramName;
    }
    const definitionStartIndex = focusedLine.indexOf('|');
    const definitionEndIndex = focusedLine.lastIndexOf('|');
    const column = position.column;
    if (definitionEndIndex >= column && definitionStartIndex <= column) {
        const lineParts = focusedLine.split('|');
        let localColIndex = lineParts[0].length + 1;
        const targetPart = lineParts[1];
        const targets = targetPart.split(' ');
        for (let i = 0; i < targets.length; i++) {
            const startIndex = localColIndex;
            const endIndex = startIndex + targets[i].length;
            if (column >= startIndex && column <= endIndex) {
                paramName = targets[i].trim();
                break;
            }
            else {
                localColIndex = endIndex + 1;
            }
        }
        return paramName;
    }
    return '';
}
exports.focusedBlockParamName = focusedBlockParamName;
class BlockParamDefinition {
    constructor(name, path) {
        this.type = 'BlockParam';
        this.name = name;
        this.path = path;
    }
    get node() {
        return this.path.node;
    }
    get componentName() {
        if (this.node.type === 'ElementNode') {
            const tagName = this.node.tag;
            if (tagName.startsWith(':')) {
                const parentNode = this.path.parent;
                if (parentNode && parentNode.type === 'ElementNode') {
                    return (0, normalizers_1.normalizeToClassicComponent)(parentNode.tag);
                }
                return '(unknown)';
            }
            return (0, normalizers_1.normalizeToClassicComponent)(tagName);
        }
        return '(unknown)';
    }
    get slotName() {
        const node = this.node;
        if (node.type === 'ElementNode') {
            if (node.tag.startsWith(':')) {
                return node.tag.replace(':', '');
            }
        }
        return 'default';
    }
    get index() {
        const node = this.path.node;
        if (node.type === 'BlockStatement' && node.program) {
            return node.program.blockParams.indexOf(this.name);
        }
        else if (node.type === 'Block') {
            return node.blockParams.indexOf(this.name);
        }
        else if (node.type === 'ElementNode') {
            return node.blockParams.indexOf(this.name);
        }
        else {
            return -1;
        }
    }
}
exports.BlockParamDefinition = BlockParamDefinition;
function maybeBlockParamDefinition(astPath, content, position) {
    if (!isBlockParamDefinition(astPath, content, position)) {
        return;
    }
    const paramName = focusedBlockParamName(content, position);
    if (paramName === '') {
        return;
    }
    return new BlockParamDefinition(paramName, astPath);
}
exports.maybeBlockParamDefinition = maybeBlockParamDefinition;
function isBlockParamDefinition(astPath, content, position) {
    const node = astPath.node;
    if (node.type !== 'Block' && node.type !== 'BlockStatement' && node.type !== 'ElementNode') {
        return;
    }
    const source = content.match(reLines);
    const focusedLine = source[position.line - 1];
    if (focusedLine.lastIndexOf('|') > position.column && focusedLine.indexOf('|') < position.column) {
        return true;
    }
}
exports.isBlockParamDefinition = isBlockParamDefinition;
function nodeLoc(node) {
    if ('toJSON' in node.loc) {
        return node.loc.toJSON();
    }
    else {
        return node.loc;
    }
}
exports.nodeLoc = nodeLoc;
function sourceForNode(node, content = '') {
    // mostly copy/pasta from ember-template-lint and tildeio/htmlbars with a few tweaks:
    // https://github.com/tildeio/htmlbars/blob/v0.14.17/packages/htmlbars-syntax/lib/parser.js#L59-L90
    // https://github.com/ember-template-lint/ember-template-lint/blob/v2.0.0-beta.3/lib/rules/base.js#L511
    if (!node || !node.loc) {
        return;
    }
    const loc = nodeLoc(node);
    const firstLine = loc.start.line - 1;
    const lastLine = loc.end.line - 1;
    let currentLine = firstLine - 1;
    const firstColumn = loc.start.column;
    const lastColumn = loc.end.column;
    const string = [];
    const source = content.match(reLines);
    if (currentLine > source.length) {
        return;
    }
    let line;
    while (currentLine < lastLine) {
        currentLine++;
        line = source[currentLine];
        if (currentLine === firstLine) {
            if (firstLine === lastLine) {
                string.push(line.slice(firstColumn, lastColumn));
            }
            else {
                string.push(line.slice(firstColumn));
            }
        }
        else if (currentLine === lastLine) {
            string.push(line.slice(0, lastColumn));
        }
        else {
            string.push(line);
        }
    }
    return string.join('');
}
exports.sourceForNode = sourceForNode;
function getLocalScope(astPath) {
    const scopeValues = [];
    let cursor = astPath.parentPath;
    while (cursor) {
        const node = cursor.node;
        if (node && (node.type === 'ElementNode' || node.type === 'Block')) {
            const params = node.blockParams;
            params.forEach((param) => {
                scopeValues.push(new BlockParamDefinition(param, cursor));
            });
        }
        cursor = cursor.parentPath;
    }
    return scopeValues;
}
exports.getLocalScope = getLocalScope;
class HandlebarsASTPathMeta {
    constructor(astPath, position, content) {
        this.astPath = astPath;
        this.position = position;
        this.content = content;
    }
    get maybeBlockParamDefinition() {
        return maybeBlockParamDefinition(this.astPath, this.content, this.position);
    }
    get maybeBlockParamDeclarationBlockPath() {
        return maybePathDeclaration(this.astPath);
    }
    get localScope() {
        return getLocalScope(this.astPath);
    }
}
class ASTPath {
    constructor(path, index, content, position) {
        this.path = path;
        this.index = index;
        this.content = content;
        this.position = position;
    }
    static toPosition(ast, position, content = '') {
        const path = _findFocusPath(ast, position);
        if (path) {
            return new ASTPath(path, path.length - 1, content, position);
        }
    }
    get node() {
        return this.path[this.index];
    }
    get parent() {
        return this.path[this.index - 1];
    }
    parentFromLevel(level) {
        return this.path[this.index - level];
    }
    metaForType(astType) {
        if (astType === 'handlebars') {
            return new HandlebarsASTPathMeta(this, this.position, this.content);
        }
        else {
            return null;
        }
    }
    sourceForNode() {
        return sourceForNode(this.node, this.content);
    }
    sourceForParent() {
        return sourceForNode(this.parent, this.content);
    }
    get parentPath() {
        if (this.index - 1 < 0) {
            return undefined;
        }
        return new ASTPath(this.path, this.index - 1, this.content, this.position);
    }
}
exports.default = ASTPath;
function _findFocusPath(node, position, seen = new Set()) {
    seen.add(node);
    let path = [];
    const range = node.loc ? nodeLoc(node) : null;
    if (range) {
        if ((0, estree_utils_1.containsPosition)(range, position)) {
            path.push(node);
        }
        else {
            return [];
        }
    }
    for (const key in node) {
        if (key === 'loc') {
            continue;
        }
        if (!Object.prototype.hasOwnProperty.call(node, key)) {
            continue;
        }
        const value = node[key];
        if (!value || typeof value !== 'object' || seen.has(value)) {
            continue;
        }
        const childPath = _findFocusPath(value, position, seen);
        if (childPath.length > 0) {
            path = path.concat(childPath);
            break;
        }
    }
    return path;
}
//# sourceMappingURL=glimmer-utils.js.map