"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PodMatcher = exports.ClassicPathMatcher = void 0;
const path = require("path");
const layout_helpers_1 = require("./layout-helpers");
class ClassicPathMatcher {
    constructor(root = '') {
        this.root = root;
        this.keys = {
            helper: ['/helpers/'],
            service: ['/services/'],
            modifier: ['/modifiers/'],
            controller: ['/controllers/'],
            route: ['/routes/', '!/components/'],
            template: ['/templates/', '!/templates/components/'],
            component: ['/components/'],
            model: ['/models/'],
            transform: ['/transforms/'],
            adapter: ['/adapters/'],
            serializer: ['/serializers/'],
            util: ['/utils/'],
        };
        this.ignores = ['/tmp/', '/dist/', '/.git/'];
    }
    setIgnores(ignores) {
        this.ignores = ignores;
    }
    matchKey(key, str) {
        const isIgnored = this.ignores.find((el) => str.includes(el));
        if (isIgnored) {
            return false;
        }
        let matched = false;
        const keys = this.keys[key];
        for (let i = 0; i < keys.length; i++) {
            const searchStr = keys[i];
            if (searchStr.charAt(0) === '!') {
                matched = str.includes(searchStr.replace('!', '')) === false;
            }
            else {
                matched = str.includes(searchStr);
            }
            if (!matched) {
                return false;
            }
        }
        return matched;
    }
    rightPartFromFirstMatch(type, fileName, extName, str, strToMatch) {
        let fullName = str.slice(str.indexOf(strToMatch) + strToMatch.length, str.length).slice(0, -extName.length);
        if (type === 'component') {
            if (['component', 'template', 'index', 'index-test', 'component-test', 'style', 'styles', 'module'].includes(fileName)) {
                fullName = fullName.replace(`/${fileName}`, '');
            }
            if (fileName.endsWith('.module')) {
                fullName = fullName.replace(`.module`, '');
            }
        }
        if (str.includes('/tests/') && fullName.endsWith('-test')) {
            fullName = fullName.replace('-test', '');
        }
        if (fullName.startsWith('./')) {
            fullName = fullName.replace('./', '');
        }
        return fullName;
    }
    metaFromPath(rawAbsoluteAbsPath) {
        const rawAbsPath = path.relative(this.root, path.resolve(rawAbsoluteAbsPath));
        const normalizedAbsPath = rawAbsPath.split(path.sep).join('/');
        // likely it's not a case for classic path matcher
        if (normalizedAbsPath.includes('__')) {
            return null;
        }
        const absPath = '/' + normalizedAbsPath;
        const isTest = (0, layout_helpers_1.isTestFile)(absPath);
        const isTemplate = (0, layout_helpers_1.isTemplatePath)(absPath);
        const isStyle = (0, layout_helpers_1.isStyleFile)(absPath);
        const kind = isStyle ? 'style' : isTemplate ? 'template' : isTest ? 'test' : 'script';
        const isAddon = absPath.includes('/addon/');
        const isInRepoAddon = absPath.includes('/lib/') || absPath.includes('/engines/');
        const isExternalAddon = absPath.includes('/node_modules/');
        const isDummy = absPath.includes('/dummy');
        const scope = isDummy || isAddon || isInRepoAddon || isExternalAddon ? 'addon' : 'application';
        const extName = path.extname(absPath);
        const fileName = path.basename(absPath, extName);
        const results = [];
        Object.keys(this.keys).forEach((propName) => {
            if (this.matchKey(propName, absPath)) {
                results.push([propName, this.rightPartFromFirstMatch(propName, fileName, extName, absPath, this.keys[propName][0])]);
            }
        });
        if (!results.length) {
            return null;
        }
        return {
            type: results[0][0],
            name: results[0][1],
            kind,
            scope,
        };
    }
}
exports.ClassicPathMatcher = ClassicPathMatcher;
class PodMatcher extends ClassicPathMatcher {
    constructor(root, podPrefix = false) {
        super(root);
        this.podPrefix = 'app/pods';
        this.keys = {
            helper: ['/helper.'],
            service: ['/service.'],
            modifier: ['/modifier.'],
            controller: ['/controller.'],
            route: ['/route.'],
            template: ['/template.'],
            component: ['/component.'],
            model: ['/model.'],
            transform: ['/transform.'],
            adapter: ['/adapter.'],
            serializer: ['/serializer.'],
            util: ['/utils/'],
        };
        if (podPrefix) {
            this.podPrefix = podPrefix;
        }
    }
    rightPartFromFirstMatch(propName, fileName, extName, str, strToMatch) {
        if (propName === 'util') {
            return super.rightPartFromFirstMatch(propName, fileName, extName, str, strToMatch);
        }
        const indexAfterPodPrefix = str.indexOf(this.podPrefix) + this.podPrefix.length + 1;
        const indexBeforeExtName = 1 + extName.length + fileName.length;
        const componentFolderPath = 'components/';
        let fullName = str.slice(indexAfterPodPrefix, str.length).slice(0, -indexBeforeExtName);
        if (fullName.startsWith(componentFolderPath)) {
            fullName = fullName.replace(componentFolderPath, '');
        }
        if (fullName.startsWith('./')) {
            fullName = fullName.replace('./', '');
        }
        return fullName;
    }
}
exports.PodMatcher = PodMatcher;
//# sourceMappingURL=path-matcher.js.map