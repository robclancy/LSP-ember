/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const vscode_languageserver_1 = require("vscode-languageserver");
const project_roots_1 = require("./project-roots");
const entry_1 = require("./definition-providers/entry");
const template_linter_1 = require("./template-linter");
const js_document_symbol_provider_1 = require("./symbols/js-document-symbol-provider");
const hbs_document_symbol_provider_1 = require("./symbols/hbs-document-symbol-provider");
const entry_2 = require("./reference-provider/entry");
const entry_3 = require("./code-action-provider/entry");
const logger_1 = require("./utils/logger");
const template_completion_provider_1 = require("./completion-provider/template-completion-provider");
const script_completion_provider_1 = require("./completion-provider/script-completion-provider");
const registry_api_1 = require("./utils/registry-api");
const usages_api_1 = require("./utils/usages-api");
const vscode_uri_1 = require("vscode-uri");
const node_1 = require("vscode-languageserver/node");
// @ts-expect-error esmodule
const debounce = require("lodash/debounce");
const layout_helpers_1 = require("./utils/layout-helpers");
const fs_provider_1 = require("./fs-provider");
const entry_4 = require("./hover-provider/entry");
const entry_5 = require("./folding-provider/entry");
const defaultServerOptions = { type: 'node', fs: 'sync' };
class Server {
    constructor(connection, options = defaultServerOptions) {
        this.flags = {
            hasExternalFileWatcher: false,
        };
        this.initializers = [];
        this.lazyInit = false;
        this.executors = {};
        if (!connection) {
            throw new Error('uELS constructor accept connection instance as first argument');
        }
        if (globalThis.process) {
            globalThis.process.title = 'unstable_ember_language_server';
        }
        this.options = { ...defaultServerOptions, ...options };
        this.connection = connection;
        this.fs = this.options.fs === 'sync' ? new fs_provider_1.default() : new fs_provider_1.AsyncFsProvider(this);
        (0, layout_helpers_1.setSyncFSSupport)(this.options.fs === 'sync');
        (0, layout_helpers_1.setRequireSupport)(this.options.type === 'node');
        // Make the text document manager listen on the connection
        // for open, change and close text document events
        (0, logger_1.setConsole)(this.connection.console);
        (0, fs_provider_1.setFSImplementation)(this.fs);
        this.templateLinter = new template_linter_1.default(this);
        this.projectRoots = new project_roots_1.default(this);
        this.documents = new vscode_languageserver_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
        this.documentSymbolProviders = [new js_document_symbol_provider_1.default(), new hbs_document_symbol_provider_1.default()];
        this.templateCompletionProvider = new template_completion_provider_1.default(this);
        this.scriptCompletionProvider = new script_completion_provider_1.default(this);
        this.definitionProvider = new entry_1.default(this);
        this.referenceProvider = new entry_2.ReferenceProvider(this);
        this.hoverProvider = new entry_4.HoverProvider(this);
        this.codeActionProvider = new entry_3.CodeActionProvider(this);
        this.foldingProvider = new entry_5.default(this);
        this.documents.listen(this.connection);
        this.onDidChangeContent = this.onDidChangeContent.bind(this);
        this._onDidChangeContent = debounce(this._onDidChangeContent.bind(this), 250);
        // Bind event handlers
        this.connection.onInitialize(this.onInitialize.bind(this));
        this.connection.onInitialized(this.onInitialized.bind(this));
        this.documents.onDidChangeContent(this.onDidChangeContent);
        this.documents.onDidOpen(this.onDidChangeContent);
        this.connection.onDidChangeWatchedFiles(this.onDidChangeWatchedFiles.bind(this));
        this.connection.onDidChangeConfiguration(this.onDidChangeConfiguration.bind(this));
        this.connection.onDocumentSymbol(this.onDocumentSymbol.bind(this));
        this.connection.onDefinition(this.onDefinition.bind(this));
        this.connection.onCompletion(this.onCompletion.bind(this));
        this.connection.onCompletionResolve(this.onCompletionResolve.bind(this));
        this.connection.onExecuteCommand(this.onExecute.bind(this));
        this.connection.onReferences(this.onReference.bind(this));
        this.connection.onHover(this.onHover.bind(this));
        this.connection.onCodeAction(this.onCodeAction.bind(this));
        this.connection.onFoldingRanges(this.onFoldingRanges.bind(this));
        this.connection.telemetry.logEvent({ connected: true });
    }
    addToRegistry(normalizedName, kind, fullPath) {
        const rawPaths = Array.isArray(fullPath) ? fullPath : [fullPath];
        const purePaths = rawPaths.filter((p) => path.isAbsolute(p));
        if (purePaths.length) {
            (0, registry_api_1.addToRegistry)(normalizedName, kind, purePaths);
            return true;
        }
        else {
            return false;
        }
    }
    getUsages(normalizedToken, resultType) {
        return (0, usages_api_1.findRelatedFiles)(normalizedToken, resultType);
    }
    getRegistry(rawRoot) {
        if (Array.isArray(rawRoot)) {
            return (0, registry_api_1.getRegistryForRoots)(rawRoot);
        }
        else {
            return (0, registry_api_1.getRegistryForRoot)(rawRoot);
        }
    }
    async setConfiguration(config) {
        // in worker mode we don't have fs access, so, we don't trying to include it
        if (this.options.type !== 'worker') {
            if (config.addons) {
                await this.projectRoots.setLocalAddons(config.addons);
            }
        }
        if (config.ignoredProjects) {
            this.projectRoots.setIgnoredProjects(config.ignoredProjects);
        }
        if (this.options.type === 'node') {
            if (config.useBuiltinLinting === false) {
                this.templateLinter.disable();
            }
            else if (config.useBuiltinLinting === true) {
                this.templateLinter.enable();
            }
        }
        else {
            this.templateLinter.disable();
        }
        if (config.collectTemplateTokens === false) {
            (0, registry_api_1.disableTemplateTokensCollection)();
        }
        else if (config.collectTemplateTokens === true) {
            (0, registry_api_1.enableTemplateTokensCollection)();
        }
        if (config.useBuiltinFoldingRangeProvider === false) {
            this.foldingProvider.disable();
        }
        else if (config.useBuiltinFoldingRangeProvider === true) {
            this.foldingProvider.enable();
        }
    }
    async executeInitializers() {
        (0, logger_1.logInfo)('UELS: executeInitializers');
        for (const initializer of this.initializers) {
            await initializer();
        }
        this.initializers = [];
    }
    onInitialized() {
        if (this.connection.workspace && this.clientCapabilities && this.clientCapabilities.workspace && this.clientCapabilities.workspace.workspaceFolders) {
            this.connection.workspace.onDidChangeWorkspaceFolders(this.onDidChangeWorkspaceFolders.bind(this));
        }
        this.executors['els.setConfig'] = async (_, __, [config]) => {
            try {
                await this.setConfiguration(config.local);
            }
            catch (e) {
                (0, logger_1.logError)(e);
            }
            if (this.lazyInit) {
                try {
                    await this.executeInitializers();
                }
                catch (e) {
                    (0, logger_1.logError)(e);
                }
            }
        };
        this.executors['els.registerProjectPath'] = async (_, __, [projectPath]) => {
            return await this.projectRoots.onProjectAdd(projectPath);
        };
        this.executors['els.provideDiagnostics'] = async (_, __, [document]) => {
            return await this.runAddonLinters(document);
        };
        this.executors['els.getProjectRegistry'] = async (_, __, [filePath]) => {
            const fullPath = path.resolve(filePath);
            const project = this.projectRoots.projectForPath(fullPath);
            if (!project) {
                return {
                    msg: 'Unable to find project by given file path, try to register it first, using els.registerProjectPath command',
                    path: filePath,
                };
            }
            await (0, layout_helpers_1.mGetProjectAddonsInfo)(project.root);
            project.invalidateRegistry();
            return {
                projectName: project.name,
                root: project.root,
                roots: project.roots,
                registry: project.registry,
            };
        };
        this.executors['els.getLegacyTemplateTokens'] = async (_, __, [projectPath]) => {
            const project = this.projectRoots.projectForPath(projectPath);
            if (!project) {
                (0, logger_1.logDebugInfo)('els.getLegacyTemplateTokens: no project');
                return {
                    msg: 'Unable to find project for path',
                    path: projectPath,
                };
            }
            (0, logger_1.logDebugInfo)('els.getLegacyTemplateTokens [before collect]');
            await (0, usages_api_1.waitForTokensToBeCollected)();
            const allTokens = (0, usages_api_1.getAllTemplateTokens)();
            const projectTokens = {
                component: {},
                routePath: {},
            };
            Object.keys(allTokens).forEach((key) => {
                Object.keys(allTokens[key]).forEach((pathName) => {
                    const meta = allTokens[key][pathName];
                    if ((0, layout_helpers_1.isFileBelongsToRoots)(project.roots, meta.source)) {
                        projectTokens[key][pathName] = {
                            source: meta.source,
                            tokens: meta.tokens,
                        };
                    }
                });
            });
            return {
                projectName: project.name,
                root: project.root,
                roots: project.roots,
                tokens: projectTokens,
            };
        };
        this.executors['els.reloadProject'] = async (_, __, [projectPath, force]) => {
            if (projectPath) {
                const project = this.projectRoots.projectForPath(projectPath);
                if (project) {
                    await this.projectRoots.reloadProject(project.root);
                    return {
                        msg: `Project reloaded`,
                        path: project.root,
                    };
                }
                else {
                    if (force) {
                        const results = await this.projectRoots.onProjectAdd(projectPath);
                        const project = this.projectRoots.projectForPath(projectPath);
                        return {
                            msg: `Project added`,
                            path: project ? project.root : 'unable to resolve project path',
                            results,
                        };
                    }
                    else {
                        return {
                            msg: 'No project found',
                            path: projectPath,
                        };
                    }
                }
            }
            else {
                await this.projectRoots.reloadProjects();
                return {
                    msg: 'Projects reloaded',
                };
            }
        };
        this.executors['els.getRelatedFiles'] = async (_, __, [filePath, flags]) => {
            const fullPath = path.resolve(filePath);
            const project = this.projectRoots.projectForPath(filePath);
            const includeMeta = typeof flags === 'object' && flags.includeMeta === true;
            if (project) {
                const item = project.matchPathToType(fullPath);
                if (item) {
                    const normalizedItem = (0, registry_api_1.normalizeMatchNaming)(item);
                    const registryResults = project.registry[normalizedItem.type][normalizedItem.name] || [];
                    if (!includeMeta) {
                        return registryResults.sort();
                    }
                    return registryResults.sort().map((filePath) => {
                        return {
                            path: filePath,
                            meta: project.matchPathToType(filePath),
                        };
                    });
                }
            }
            return [];
        };
        this.executors['els.getKindUsages'] = async (_, __, [filePath]) => {
            const fullPath = path.resolve(filePath);
            const project = this.projectRoots.projectForPath(filePath);
            if (project) {
                const item = project.matchPathToType(fullPath);
                if (item) {
                    return {
                        name: item.name,
                        path: filePath,
                        type: item.type,
                        usages: this.getUsages(item.name, item.type).map((usage) => {
                            if (usage.type === 'routePath') {
                                return {
                                    ...usage,
                                    type: 'template',
                                };
                            }
                            return usage;
                        }),
                    };
                }
            }
            return [];
        };
    }
    async onCodeAction(params) {
        try {
            const results = await this.codeActionProvider.provideCodeActions(params);
            return results;
        }
        catch (e) {
            (0, logger_1.logError)(e);
            return null;
        }
    }
    onFoldingRanges(params) {
        return this.foldingProvider.onFoldingRanges(params);
    }
    /**
     * Custom Notifications
     */
    displayInfoMessage(msg) {
        this.connection.sendNotification('$/displayInfo', msg);
    }
    displayWarningMessage(msg) {
        this.connection.sendNotification('$/displayWarning', msg);
    }
    displayErrorMessage(msg) {
        this.connection.sendNotification('$/displayError', msg);
    }
    async onExecute(params) {
        if (!params) {
            return;
        }
        if (params.command in this.executors) {
            const result = await this.executors[params.command](this, params.command, params.arguments || []);
            return result;
        }
        else {
            const [uri, ...args] = params.arguments || [];
            try {
                const project = this.projectRoots.projectForPath(uri);
                let result = null;
                if (project) {
                    if (params.command in project.executors) {
                        result = await project.executors[params.command](this, uri, args);
                    }
                }
                return result;
            }
            catch (e) {
                (0, logger_1.logError)(e);
            }
        }
        return params;
    }
    listen() {
        this.connection.listen();
    }
    onDidChangeWorkspaceFolders(event) {
        if (event.added.length) {
            event.added.forEach((folder) => {
                this.projectRoots.findProjectsInsideRoot(vscode_uri_1.URI.parse(folder.uri).fsPath);
            });
        }
    }
    // After the server has started the client sends an initilize request. The server receives
    // in the passed params the rootPath of the workspace plus the client capabilites.
    async onInitialize({ rootUri, rootPath, workspaceFolders, initializationOptions, capabilities }) {
        rootPath = rootUri ? vscode_uri_1.URI.parse(rootUri).fsPath : rootPath;
        this.clientCapabilities = capabilities || {};
        if (!rootPath) {
            return { capabilities: {} };
        }
        if (initializationOptions && initializationOptions.editor && initializationOptions.editor === 'vscode') {
            (0, logger_1.logInfo)('lazy init enabled, waiting for config from VSCode');
            this.lazyInit = true;
            this.flags.hasExternalFileWatcher = true;
        }
        if (initializationOptions && initializationOptions.isELSTesting) {
            await this.onInitialized();
            (0, logger_1.setConsole)(null); //no console for testing as we use stdio for communication
        }
        (0, logger_1.log)(`Initializing Ember Language Server at ${rootPath}`);
        this.initializers.push(async () => {
            await this.projectRoots.initialize(rootPath);
            if (workspaceFolders && Array.isArray(workspaceFolders)) {
                for (const folder of workspaceFolders) {
                    const folderPath = vscode_uri_1.URI.parse(folder.uri).fsPath;
                    if (folderPath && rootPath !== folderPath) {
                        await this.projectRoots.findProjectsInsideRoot(folderPath);
                    }
                }
            }
        });
        if (!this.lazyInit) {
            await this.executeInitializers();
        }
        // this.setStatusText('Initialized');
        const info = (await (0, layout_helpers_1.asyncGetJSON)(path.join(__dirname, './../package.json')));
        return {
            serverInfo: {
                name: info.name,
                version: info.version,
            },
            capabilities: {
                // Tell the client that the server works in FULL text document sync mode
                textDocumentSync: vscode_languageserver_1.TextDocumentSyncKind.Full,
                definitionProvider: true,
                executeCommandProvider: {
                    commands: [
                        'els.registerProjectPath',
                        'els.provideDiagnostics',
                        'els.extractSourceCodeToComponent',
                        'els.executeInEmberCLI',
                        'els.getRelatedFiles',
                        'els.getKindUsages',
                        'els.setConfig',
                        'els.reloadProject',
                    ],
                },
                documentSymbolProvider: true,
                foldingRangeProvider: true,
                codeActionProvider: true,
                referencesProvider: true,
                hoverProvider: true,
                workspace: {
                    workspaceFolders: {
                        supported: true,
                        changeNotifications: true,
                    },
                },
                completionProvider: {
                    resolveProvider: true,
                    triggerCharacters: ['.', '::', '$', '=', '/', '{{', '(', '<', '@', 'this.', '<:'],
                },
            },
        };
    }
    sendCommand(command, ...options) {
        return this.connection.sendRequest(vscode_languageserver_1.ExecuteCommandRequest.type.method, {
            command,
            arguments: options,
        });
    }
    async runAddonLinters(document) {
        const results = [];
        const project = this.projectRoots.projectForUri(document.uri);
        if (project) {
            for (const linter of project.linters) {
                try {
                    const tempResults = await linter(document);
                    // API must return array
                    if (Array.isArray(tempResults)) {
                        tempResults.forEach((el) => {
                            results.push(el);
                        });
                    }
                }
                catch (e) {
                    (0, logger_1.logError)(e);
                }
            }
        }
        return results;
    }
    async onDidChangeContent(change) {
        this.lastChangeEvent = change;
        this._onDidChangeContent();
    }
    async _onDidChangeContent() {
        // this.setStatusText('did-change');
        const change = this.lastChangeEvent;
        const lintResults = await this.templateLinter.lint(change.document);
        if (change !== this.lastChangeEvent) {
            return;
        }
        if (Array.isArray(lintResults)) {
            this.connection.sendDiagnostics({ version: change.document.version, uri: change.document.uri, diagnostics: lintResults });
        }
        const addonResults = await this.runAddonLinters(change.document);
        if (change !== this.lastChangeEvent) {
            return;
        }
        const project = this.projectRoots.projectForUri(change.document.uri);
        if (project) {
            project.trackChange(change.document.uri, node_1.FileChangeType.Changed);
        }
        this.connection.sendDiagnostics({
            version: change.document.version,
            uri: change.document.uri,
            diagnostics: [...(lintResults || []), ...(addonResults || [])],
        });
    }
    onDidChangeWatchedFiles(items) {
        items.changes.forEach((change) => {
            const project = this.projectRoots.projectForUri(change.uri);
            if (project) {
                project.trackChange(change.uri, change.type);
            }
            else {
                if (change.type === 1 && change.uri.endsWith('ember-cli-build.js')) {
                    const rawPath = vscode_uri_1.URI.parse(change.uri).fsPath;
                    if (rawPath) {
                        const filePath = path.dirname(path.resolve(rawPath));
                        this.projectRoots.findProjectsInsideRoot(filePath);
                    }
                }
            }
        });
        // /**
        //  * The file got created.
        //  */
        // const Created = 1;
        // /**
        //  * The file got changed.
        //  */
        // const Changed = 2;
        // /**
        //  * The file got deleted.
        //  */
        // const Deleted = 3;
    }
    async onDidChangeConfiguration({ settings }) {
        await this.setConfiguration(settings);
    }
    async onReference(params) {
        return await this.referenceProvider.provideReferences(params);
    }
    async onHover(params) {
        return await this.hoverProvider.provideHover(params);
    }
    async onDefinition(params) {
        return this.definitionProvider.handle(params);
    }
    async onCompletionResolve(item) {
        return item;
    }
    async onCompletion(textDocumentPosition) {
        const completionItems = [];
        try {
            const [templateCompletions, scriptCompletions] = await Promise.all([
                await this.templateCompletionProvider.provideCompletions(textDocumentPosition),
                await this.scriptCompletionProvider.provideCompletions(textDocumentPosition),
            ]);
            completionItems.push(...templateCompletions, ...scriptCompletions);
        }
        catch (e) {
            (0, logger_1.logError)(e);
            (0, logger_1.logDebugInfo)('onCompletionError', textDocumentPosition, e, e.stack, e.toString());
        }
        // this.setStatusText('Running');
        return completionItems;
    }
    // public setStatusText(text: string) {
    // this.connection.sendNotification('els.setStatusBarText', [text]);
    // }
    async onDocumentSymbol(params) {
        const uri = params.textDocument.uri;
        const filePath = vscode_uri_1.URI.parse(uri).fsPath;
        if (!filePath) {
            return [];
        }
        const extension = path.extname(filePath);
        const providers = this.documentSymbolProviders.filter((provider) => provider.extensions.indexOf(extension) !== -1);
        if (providers.length === 0)
            return [];
        const content = await this.fs.readFile(filePath);
        if (content === null) {
            return [];
        }
        return providers.map((providers) => providers.process(content)).reduce((a, b) => a.concat(b), []);
    }
}
exports.default = Server;
//# sourceMappingURL=server.js.map