"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPathExpression = exports.isLinkComponentRouteTarget = exports.isElementAttribute = exports.isComponentArgumentName = exports.isScopedPathExpression = exports.isArgumentPathExpression = exports.isLocalPathExpression = exports.isLocalizationHelperTranslataionName = exports.isModelReference = exports.isNamedServiceInjection = exports.isServiceInjection = exports.isImportDefaultSpecifier = exports.isImportSpecifier = exports.isImportPathDeclaration = exports.isBlockLinkToTarget = exports.isInlineLinkToTarget = exports.isOutlet = exports.isLinkToTarget = exports.isSubExpressionPath = exports.isHashPairValue = exports.isHashPair = exports.isBlockPath = exports.isMustachePath = exports.isModifierPath = exports.isAngleComponentPath = exports.isScopedAngleTagName = exports.isSpecialHelperStringPositionalParam = exports.isNamedBlockName = exports.isTransformReference = exports.isComputedPropertyArgument = exports.isStoreModelLookup = exports.isTemplateElement = exports.isRouteLookup = exports.closestScriptNodeParent = void 0;
const HTML_TAGS = [
    'a',
    'abbr',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'bdi',
    'bdo',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dd',
    'del',
    'details',
    'dfn',
    'dialog',
    'div',
    'dl',
    'dt',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'link',
    'main',
    'map',
    'mark',
    'math',
    'menu',
    'menuitem',
    'meta',
    'meter',
    'nav',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'param',
    'picture',
    'pre',
    'progress',
    'q',
    'rb',
    'rp',
    'rt',
    'rtc',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'slot',
    'small',
    'source',
    'span',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'svg',
    'table',
    'tbody',
    'td',
    'template',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'track',
    'u',
    'ul',
    'var',
    'video',
    'wbr',
];
function isFirstStringParamInCallExpression(astPath) {
    const node = astPath.node;
    if (!isString(node)) {
        return false;
    }
    const parent = astPath.parent;
    if (!isCallExpression(parent)) {
        return false;
    }
    if (!expressionHasArgument(parent, node, 0)) {
        return false;
    }
    if (!parent.callee || !parent.callee.property) {
        return false;
    }
    return true;
}
function closestScriptNodeParent(astPath, type, ignoreParents = []) {
    let lookupPath = astPath;
    while (lookupPath && lookupPath.parent) {
        if (hasNodeType(lookupPath.node, type)) {
            if (!lookupPath.parent) {
                return lookupPath.node;
            }
            if (!ignoreParents.includes(lookupPath.parent.type)) {
                return lookupPath.node;
            }
        }
        else {
            lookupPath = lookupPath.parentPath;
        }
    }
    return null;
}
exports.closestScriptNodeParent = closestScriptNodeParent;
function isRouteLookup(astPath) {
    if (!isFirstStringParamInCallExpression(astPath)) {
        return false;
    }
    const parent = astPath.parent;
    const matches = ['transitionTo', 'replaceWith', 'replaceRoute', 'modelFor', 'controllerFor', 'intermediateTransitionTo', 'paramsFor', 'transitionToRoute'];
    return expressionHasIdentifierName(parent, matches);
}
exports.isRouteLookup = isRouteLookup;
function isTemplateElement(astPath) {
    const node = astPath.node;
    if (node.type !== 'TemplateElement') {
        return false;
    }
    const parent = astPath.parent;
    if (parent.type !== 'TemplateLiteral') {
        return false;
    }
    const grandpa = astPath.parentPath && astPath.parentPath.parent;
    if (grandpa.type !== 'TaggedTemplateExpression') {
        return false;
    }
    if (grandpa.tag && grandpa.tag.type === 'Identifier' && grandpa.tag.name === 'hbs') {
        return true;
    }
    return false;
}
exports.isTemplateElement = isTemplateElement;
function isStoreModelLookup(astPath) {
    if (!isFirstStringParamInCallExpression(astPath)) {
        return false;
    }
    const parent = astPath.parent;
    const matches = ['findRecord', 'createRecord', 'findAll', 'queryRecord', 'peekAll', 'query', 'peekRecord', 'adapterFor', 'hasRecordForId'];
    return expressionHasIdentifierName(parent, matches);
}
exports.isStoreModelLookup = isStoreModelLookup;
function isComputedPropertyArgument(astPath) {
    const node = astPath.node;
    if (!isString(node)) {
        return false;
    }
    const parent = astPath.parent;
    if (!isCallExpression(parent)) {
        return false;
    }
    if (!expressionHasArgument(parent, node)) {
        return false;
    }
    if (!expressionHasIdentifierName(parent, [
        'computed',
        'and',
        'alias',
        'bool',
        'collect',
        'deprecatingAlias',
        'empty',
        'equal',
        'filter',
        'filterBy',
        'gt',
        'gte',
        'intersect',
        'lt',
        'lte',
        'map',
        'mapBy',
        'match',
        'max',
        'min',
        'none',
        'not',
        'notEmpty',
        'oneWay',
        'or',
        'readOnly',
        'reads',
        'setDiff',
        'sort',
        'sum',
        'union',
        'uniq',
        'uniqBy',
        'notifyPropertyChange',
        'toggleProperty',
        'cacheFor',
        'addObserver',
        'removeObserver',
        'incrementProperty',
        'decrementDecrementProperty',
        'set',
        'get',
        'getWithDefault ',
    ])) {
        return false;
    }
    const grandParent = astPath.parentPath;
    if (!grandParent) {
        return false;
    }
    return true;
}
exports.isComputedPropertyArgument = isComputedPropertyArgument;
function isTransformReference(astPath) {
    const node = astPath.node;
    if (!isString(node)) {
        return false;
    }
    const parent = astPath.parent;
    if (!isCallExpression(parent)) {
        return false;
    }
    if (!expressionHasArgument(parent, node, 0)) {
        return false;
    }
    return expressionHasIdentifierName(parent, 'attr');
}
exports.isTransformReference = isTransformReference;
function isNamedBlockName(path) {
    return isAngleComponentPath(path) && path.parent && path.node.tag.startsWith(':');
}
exports.isNamedBlockName = isNamedBlockName;
function isSpecialHelperStringPositionalParam(helperName, astPath) {
    const node = astPath.node;
    if (!isString(node)) {
        return false;
    }
    const parentPath = astPath.parentPath;
    if (!parentPath) {
        return false;
    }
    if (!hasNodeType(parentPath.node, 'SubExpression')) {
        return false;
    }
    const parentNode = parentPath.node;
    if (parentNode.params.indexOf(node) !== 0) {
        return false;
    }
    return parentNode.path.type === 'PathExpression' && parentNode.path.original === helperName;
}
exports.isSpecialHelperStringPositionalParam = isSpecialHelperStringPositionalParam;
function isScopedAngleTagName(path) {
    const node = path.node;
    if (!hasNodeType(node, 'ElementNode')) {
        return false;
    }
    if (node.tag.startsWith('@')) {
        // have no idea how to handle it in context
        return false;
    }
    if (node.tag.startsWith('this.')) {
        // have no idea how to handle it in context
        return false;
    }
    if (node.tag.startsWith(':')) {
        // have no idea how to handle it in context
        return false;
    }
    return !HTML_TAGS.includes(node.tag);
}
exports.isScopedAngleTagName = isScopedAngleTagName;
function isAngleComponentPath(path) {
    const node = path.node;
    if (!hasNodeType(node, 'ElementNode')) {
        return false;
    }
    if (node.tag.charAt(0) === node.tag.charAt(0).toUpperCase()) {
        return true;
    }
    else {
        return false;
    }
}
exports.isAngleComponentPath = isAngleComponentPath;
function isModifierPath(path) {
    const node = path.node;
    if (!isPathExpression(node)) {
        return false;
    }
    if (node.head.type === 'AtHead') {
        return false;
    }
    const parent = path.parent;
    if (!hasNodeType(parent, 'ElementModifierStatement')) {
        return false;
    }
    return node === parent.path;
}
exports.isModifierPath = isModifierPath;
function isMustachePath(path) {
    const node = path.node;
    if (!isPathExpression(node)) {
        return false;
    }
    const parent = path.parent;
    if (!hasNodeType(parent, 'MustacheStatement')) {
        return false;
    }
    return parent.path === node;
}
exports.isMustachePath = isMustachePath;
function isBlockPath(path) {
    const node = path.node;
    if (!isPathExpression(node)) {
        return false;
    }
    const parent = path.parent;
    if (!isBlock(parent)) {
        return false;
    }
    return parent.path === node;
}
exports.isBlockPath = isBlockPath;
function isHashPair(path) {
    const node = path.node;
    if (!hasNodeType(node, 'HashPair')) {
        return false;
    }
    return true;
}
exports.isHashPair = isHashPair;
function isHashPairValue(path) {
    return path.parent && isHashPair(path.parentPath) && path.parent.value === path.node;
}
exports.isHashPairValue = isHashPairValue;
function isSubExpressionPath(path) {
    const node = path.node;
    if (!isPathExpression(node)) {
        return false;
    }
    const parent = path.parent;
    if (!hasNodeType(parent, 'SubExpression')) {
        return false;
    }
    return parent.path === node;
}
exports.isSubExpressionPath = isSubExpressionPath;
function isLinkToTarget(path) {
    return isInlineLinkToTarget(path) || isBlockLinkToTarget(path);
}
exports.isLinkToTarget = isLinkToTarget;
function isOutlet(path) {
    if (isPathExpression(path.node)) {
        const node = path.node;
        return node.original === 'outlet' && node.head.type === 'VarHead';
    }
    return false;
}
exports.isOutlet = isOutlet;
function isInlineLinkToTarget(path) {
    const node = path.node;
    if (!isString(node)) {
        return false;
    }
    const parent = path.parent;
    if (!hasNodeType(parent, 'MustacheStatement')) {
        return false;
    }
    return parent.params[1] === node && parent.path && parent.path.original === 'link-to';
}
exports.isInlineLinkToTarget = isInlineLinkToTarget;
function isBlockLinkToTarget(path) {
    const node = path.node;
    if (!isString(node)) {
        return false;
    }
    const parent = path.parent;
    if (!isBlock(parent)) {
        return false;
    }
    return parent.params[0] === node && parent.path && parent.path.original === 'link-to';
}
exports.isBlockLinkToTarget = isBlockLinkToTarget;
function isImportPathDeclaration(path) {
    const node = path.node;
    if (!isString(node)) {
        return false;
    }
    const parent = path.parent;
    if (!hasNodeType(parent, 'ImportDeclaration')) {
        return false;
    }
    return true;
}
exports.isImportPathDeclaration = isImportPathDeclaration;
function isImportSpecifier(path) {
    if (!hasNodeType(path.parent, 'ImportSpecifier')) {
        return false;
    }
    return true;
}
exports.isImportSpecifier = isImportSpecifier;
function isImportDefaultSpecifier(path) {
    if (!hasNodeType(path.parent, 'ImportDefaultSpecifier')) {
        return false;
    }
    return true;
}
exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
function isServiceInjection(path) {
    const node = path.node;
    if (!hasNodeType(node, 'Identifier')) {
        return false;
    }
    const parent = path.parent;
    if (!hasNodeType(parent, 'ObjectProperty')) {
        return false;
    }
    if (!isCallExpression(parent.value)) {
        return false;
    }
    return expressionHasIdentifierName(parent.value, 'service');
}
exports.isServiceInjection = isServiceInjection;
function isNamedServiceInjection(path) {
    const node = path.node;
    if (!isString(node)) {
        return false;
    }
    const parent = path.parent;
    if (!isCallExpression(parent)) {
        return false;
    }
    return expressionHasIdentifierName(parent, 'service');
}
exports.isNamedServiceInjection = isNamedServiceInjection;
function isModelReference(astPath) {
    const node = astPath.node;
    if (!isString(node)) {
        return false;
    }
    const parent = astPath.parent;
    if (!isCallExpression(parent)) {
        return false;
    }
    if (!expressionHasArgument(parent, node, 0)) {
        return false;
    }
    return expressionHasIdentifierName(parent, ['belongsTo', 'hasMany']);
}
exports.isModelReference = isModelReference;
function isLocalizationHelperTranslataionName(focusPath, type) {
    const parent = focusPath.parent;
    if (!parent) {
        return false;
    }
    if (type === 'script' && isString(focusPath.node)) {
        const isMemberExp = isCallExpression(parent) && parent.callee && parent.callee.type === 'MemberExpression';
        const hasValidCallee = isMemberExp && expressionHasIdentifierName(parent, 't');
        return hasValidCallee && expressionHasArgument(parent, focusPath.node, 0);
    }
    return (type === 'template' && isString(focusPath.node) && (parent.type === 'MustacheStatement' || parent.type === 'SubExpression') && parent.path.original === 't');
}
exports.isLocalizationHelperTranslataionName = isLocalizationHelperTranslataionName;
function hasNodeType(node, type) {
    if (!node) {
        return false;
    }
    return node.type === type;
}
function isBlock(node) {
    return hasNodeType(node, 'BlockStatement');
}
function isString(node) {
    return hasNodeType(node, 'StringLiteral');
}
function isCallExpression(node) {
    return hasNodeType(node, 'CallExpression');
}
function isLocalPathExpression(path) {
    return isPathExpression(path.node) && path.node.this === true;
}
exports.isLocalPathExpression = isLocalPathExpression;
function isArgumentPathExpression(path) {
    return isPathExpression(path.node) && path.node.data === true;
}
exports.isArgumentPathExpression = isArgumentPathExpression;
function isScopedPathExpression(path) {
    return isPathExpression(path.node) && path.node.this === false && path.node.data === false;
}
exports.isScopedPathExpression = isScopedPathExpression;
function isComponentArgumentName(path) {
    return isElementAttribute(path) && path.node.name.startsWith('@');
}
exports.isComponentArgumentName = isComponentArgumentName;
function isElementAttribute(path) {
    return hasNodeType(path.node, 'AttrNode');
}
exports.isElementAttribute = isElementAttribute;
function isLinkComponentRouteTarget(path) {
    return hasNodeType(path.node, 'TextNode') && hasNodeType(path.parent, 'AttrNode') && path.parent.name === '@route';
}
exports.isLinkComponentRouteTarget = isLinkComponentRouteTarget;
function isPathExpression(node) {
    return hasNodeType(node, 'PathExpression');
}
exports.isPathExpression = isPathExpression;
function expressionHasIdentifierName(exp, name) {
    const names = typeof name === 'string' ? [name] : name;
    const identifier = hasNodeType(exp.callee, 'Identifier') ? exp.callee : exp.callee.property;
    return names.includes(identifier.name);
}
function expressionHasArgument(exp, arg, position = -1) {
    if (!exp || !exp.arguments) {
        return false;
    }
    const index = exp.arguments.indexOf(arg);
    if (index === -1) {
        return false;
    }
    if (position === -1) {
        return true;
    }
    if (position === index) {
        return true;
    }
    else {
        return false;
    }
}
//# sourceMappingURL=ast-helpers.js.map