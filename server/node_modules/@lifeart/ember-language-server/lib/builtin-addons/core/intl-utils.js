"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTranslations = exports.getEmberIntlConfig = void 0;
const flat = require("flat");
const json_parse_ast_1 = require("json-parse-ast");
const path = require("path");
const YAML = require("yaml");
const vscode_languageserver_1 = require("vscode-languageserver");
const vscode_uri_1 = require("vscode-uri");
const logger_1 = require("../../utils/logger");
const layout_helpers_1 = require("../../utils/layout-helpers");
const YAML_EXTENSIONS = ['.yaml', '.yml'];
function getEmberIntlConfig(root) {
    try {
        if (!(0, layout_helpers_1.getRequireSupport)()) {
            return null;
        }
        // @ts-expect-error @todo - fix webpack imports
        const requireFunc = typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;
        // eslint-disable-next-line @typescript-eslint/no-var-requires
        const intlConfig = requireFunc(path.join(root, 'config', 'ember-intl.js'));
        if (!intlConfig) {
            return null;
        }
        return typeof intlConfig === 'function' ? intlConfig() : intlConfig;
    }
    catch (e) {
        // logDebugInfo('catch', e);
        return null;
    }
}
exports.getEmberIntlConfig = getEmberIntlConfig;
async function getTranslations(root, server) {
    const hashMap = {};
    const intlEntry = path.join(root, 'translations');
    const intlEntryExists = await server.fs.exists(intlEntry);
    if (intlEntryExists) {
        await recursiveIntlTranslationsSearch(server, hashMap, intlEntry, root);
    }
    return hashMap;
}
exports.getTranslations = getTranslations;
async function recursiveIntlTranslationsSearch(server, hashMap, startPath, root) {
    const localizations = await server.fs.readDirectory(startPath);
    for (const [fileName] of localizations) {
        const extName = path.extname(fileName);
        const localization = path.basename(fileName, extName);
        const filePath = path.join(startPath, fileName);
        try {
            const fileStats = await server.fs.stat(filePath);
            if (fileStats.isDirectory()) {
                await recursiveIntlTranslationsSearch(server, hashMap, filePath, root);
            }
            else {
                const translationFile = await objFromFile(server, filePath);
                if (!translationFile.json) {
                    return;
                }
                addToHashMap(hashMap, translationFile, localization, filePath, root);
            }
        }
        catch (e) {
            (0, logger_1.logDebugInfo)('error', e);
        }
    }
}
async function objFromFile(server, filePath) {
    const ext = path.extname(filePath);
    if (YAML_EXTENSIONS.includes(ext)) {
        const content = await server.fs.readFile(filePath);
        if (content === null) {
            return {};
        }
        const lineCounter = new YAML.LineCounter();
        const ast = YAML.parseDocument(content, { lineCounter }).contents;
        return { type: 'yaml', json: YAML.parse(content), yamlAst: ast, yamlLineCounter: lineCounter };
    }
    else if (ext === '.json') {
        const content = await server.fs.readFile(filePath);
        if (content === null) {
            return {};
        }
        const ast = (0, json_parse_ast_1.parseTokens)((0, json_parse_ast_1.tokenize)(content));
        return { type: 'json', json: JSON.parse(content), jsonAst: ast };
    }
    return {};
}
function generateTranslationKey(key, filePath, root) {
    const config = getEmberIntlConfig(root);
    const wrapTranslationsWithNamespace = config === null || config === void 0 ? void 0 : config.wrapTranslationsWithNamespace;
    if (!wrapTranslationsWithNamespace) {
        return key;
    }
    const dirname = path
        .dirname(filePath)
        .replace(new RegExp(`.*\\${path.sep}translations(\\${path.sep})?`), '')
        .replace(new RegExp(`\\${path.sep}`, 'g'), '.');
    return dirname.length ? `${dirname}.${key}` : key;
}
function addToHashMap(hash, translationFile, locale, filePath, root) {
    const items = flat(translationFile.json);
    const extension = path.extname(filePath);
    Object.keys(items).forEach((p) => {
        const key = generateTranslationKey(p, filePath, root);
        if (!(key in hash)) {
            hash[key] = [];
        }
        const uri = vscode_uri_1.URI.file(filePath).toString();
        let position;
        if (extension === '.json' && translationFile.type === 'json') {
            position = getPositionInJson(translationFile.jsonAst, p);
        }
        else if (YAML_EXTENSIONS.includes(extension) && translationFile.type === 'yaml') {
            position = getPositionInYaml(translationFile.yamlAst, p, translationFile.yamlLineCounter);
        }
        const startLine = position ? position.start.line - 1 : 0;
        const endLine = position ? position.end.line - 1 : 0;
        const startColumn = position ? position.start.column - 1 : 0;
        const endColumn = position ? position.end.column - 1 : 0;
        const range = vscode_languageserver_1.Range.create(startLine, startColumn, endLine, endColumn);
        hash[key].push({ locale, text: items[p], location: vscode_languageserver_1.Location.create(uri, range) });
    });
}
function getPositionInJson(ast, path) {
    var _a;
    const keys = path.split('.');
    let keypos = 0;
    let position;
    function traverseJsonAst(node) {
        var _a;
        if (node.type === 'Object') {
            const entries = (_a = node.extractValues) === null || _a === void 0 ? void 0 : _a.call(node);
            for (let i = 0; i < entries.length; i++) {
                const entry = entries[i];
                if (entry.key.value === keys[keypos]) {
                    keypos++;
                    if (keypos === keys.length) {
                        return entry;
                    }
                    return traverseJsonAst(entry.value);
                }
            }
        }
    }
    const jsonAstNode = traverseJsonAst(ast);
    const valuePosition = jsonAstNode === null || jsonAstNode === void 0 ? void 0 : jsonAstNode.value.position;
    const keyPosition = (_a = jsonAstNode === null || jsonAstNode === void 0 ? void 0 : jsonAstNode.key) === null || _a === void 0 ? void 0 : _a.position;
    if (jsonAstNode && valuePosition && keyPosition) {
        position = {
            start: { line: keyPosition.startLineNumber, column: keyPosition.startColumn - 1 },
            end: { line: valuePosition.endLineNumber, column: valuePosition.endColumn - 1 },
        };
    }
    return position;
}
function getPositionInYaml(ast, path, lineCounter) {
    const keys = path.split('.');
    let keypos = 0;
    let position;
    function traverseYamlAst(node) {
        var _a, _b, _c;
        for (let i = 0; i < node.items.length; i++) {
            const item = node.items[i];
            if (keys[keypos] === item.key.value) {
                keypos++;
                if (keypos === keys.length) {
                    return { start: (_a = item.key.range) === null || _a === void 0 ? void 0 : _a[0], end: (_c = (_b = item.value) === null || _b === void 0 ? void 0 : _b.range) === null || _c === void 0 ? void 0 : _c[1] };
                }
                return traverseYamlAst(item.value);
            }
        }
    }
    const yamlPosition = traverseYamlAst(ast);
    if (yamlPosition && yamlPosition.start != null && yamlPosition.end != null) {
        const startPos = lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.linePos(yamlPosition.start);
        const endPos = lineCounter === null || lineCounter === void 0 ? void 0 : lineCounter.linePos(yamlPosition.end);
        if (startPos && endPos) {
            position = {
                start: { line: startPos.line, column: startPos.col },
                end: { line: endPos.line, column: endPos.col },
            };
        }
    }
    return position;
}
//# sourceMappingURL=intl-utils.js.map