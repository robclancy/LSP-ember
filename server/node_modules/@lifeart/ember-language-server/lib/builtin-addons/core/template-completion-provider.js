"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateNamespacedComponentsHashMap = void 0;
const node_1 = require("vscode-languageserver/node");
// @ts-expect-error esmodule
const uniqBy = require("lodash/uniqBy");
const memoize = require("memoizee");
const ember_helpers_1 = require("./ember-helpers");
const template_definition_provider_1 = require("./template-definition-provider");
const logger_1 = require("../../utils/logger");
const glimmer_utils_1 = require("../../glimmer-utils");
const ast_helpers_1 = require("../../utils/ast-helpers");
const layout_helpers_1 = require("../../utils/layout-helpers");
const normalizers_1 = require("../../utils/normalizers");
const template_tokens_collector_1 = require("../../utils/template-tokens-collector");
const vscode_uri_1 = require("vscode-uri");
const template_context_provider_1 = require("./template-context-provider");
const autocomplete_1 = require("../doc/autocomplete");
const usages_api_1 = require("../../utils/usages-api");
const mListModifiers = memoize(layout_helpers_1.listModifiers, { length: 1, maxAge: 60000 }); // 1 second
const mListComponents = memoize(layout_helpers_1.listComponents, { length: 1, maxAge: 60000 }); // 1 second
const mListPodsComponents = memoize(layout_helpers_1.listPodsComponents, {
    length: 1,
    maxAge: 60000,
}); // 1 second
const mListHelpers = memoize(layout_helpers_1.listHelpers, { length: 1, maxAge: 60000 }); // 1 second
const mListRoutes = memoize(layout_helpers_1.listRoutes, { length: 1, maxAge: 60000 });
/**
 * Generates a map of completion label (file name) to array of potential namespaced
 * paths.
 * @param addonsMeta addons meta array
 * @param server Server
 * @param focusPath currentfocus path
 * @returns { [key: string]: string[] }
 */
function generateNamespacedComponentsHashMap(addonsMeta, server, isAngleComponent) {
    const resultMap = {};
    // Iterate over the addons meta
    addonsMeta.forEach((addonData) => {
        if (addonData.version !== 1) {
            return;
        }
        // Get the component registry based on the addon root.
        // The component registry is a map where the file name is the key and the value are
        // potential file paths.
        // Eg: { foo: ['bar/bang/biz/foo.js'] }
        const addonRegistry = server.getRegistry(addonData.root).component;
        // For each addon meta, generate the namespaced label.
        Object.keys(addonRegistry).forEach((addonItem) => {
            const addonFilePaths = addonRegistry[addonItem];
            const itemLabel = isAngleComponent ? (0, normalizers_1.normalizeToAngleBracketComponent)(addonItem) : addonItem;
            if (!resultMap[itemLabel]) {
                resultMap[itemLabel] = [];
            }
            // If file paths are present, then iterate over the filepath and generate the
            // namespaced label
            if (addonFilePaths.length) {
                addonFilePaths.forEach((filePath) => {
                    // Check if filepath starts with addon's root
                    if ((0, layout_helpers_1.isRootStartingWithFilePath)(addonData.root, filePath)) {
                        const rootNameParts = addonData.name.split('/');
                        const addonName = rootNameParts.pop() || '';
                        const label = isAngleComponent
                            ? `${(0, normalizers_1.normalizeToAngleBracketComponent)(addonName)}$${(0, normalizers_1.normalizeToAngleBracketComponent)(addonItem)}`
                            : `${addonName}$${addonItem}`;
                        if (!resultMap[itemLabel].includes(label)) {
                            resultMap[itemLabel].push(label);
                        }
                    }
                });
            }
        });
    });
    return resultMap;
}
exports.generateNamespacedComponentsHashMap = generateNamespacedComponentsHashMap;
function isArgumentName(name) {
    return name.startsWith('@');
}
class TemplateCompletionProvider {
    constructor() {
        this.hasNamespaceSupport = false;
        this.meta = {
            projectAddonsInfoInitialized: false,
            helpersRegistryInitialized: false,
            modifiersRegistryInitialized: false,
            componentsRegistryInitialized: false,
            podComponentsRegistryInitialized: false,
            routesRegistryInitialized: false,
        };
    }
    get registry() {
        return this.project.registry;
    }
    enableRegistryCache(value) {
        if (this.server.flags.hasExternalFileWatcher) {
            this.meta[value] = true;
        }
        else {
            this.server.connection.console.warn('Unable to user global registry state, falling back to cache api, to fix this message install [els-addon-file-watcher]');
        }
    }
    async initRegistry(_, project) {
        this.project = project;
        this.server = _;
        this.hasNamespaceSupport = await (0, layout_helpers_1.hasNamespaceSupport)(project.root);
        if (project.flags.enableEagerRegistryInitialization) {
            try {
                const initStartTime = Date.now();
                await mListHelpers(project);
                this.enableRegistryCache('helpersRegistryInitialized');
                await mListModifiers(project);
                this.enableRegistryCache('modifiersRegistryInitialized');
                await mListRoutes(project);
                this.enableRegistryCache('routesRegistryInitialized');
                await mListComponents(project);
                this.enableRegistryCache('componentsRegistryInitialized');
                await (0, layout_helpers_1.mGetProjectAddonsInfo)(project.root);
                this.enableRegistryCache('projectAddonsInfoInitialized');
                this.project.invalidateRegistry();
                (0, logger_1.logInfo)(project.root + ': registry initialized in ' + (Date.now() - initStartTime) + 'ms');
            }
            catch (e) {
                (0, logger_1.logError)(e);
            }
        }
        else {
            (0, logger_1.logInfo)('EagerRegistryInitialization is disabled for "' + project.name + '" (template-completion-provider)');
        }
    }
    async getAllAngleBracketComponents(root) {
        const items = [];
        if (!this.meta.projectAddonsInfoInitialized) {
            await (0, layout_helpers_1.mGetProjectAddonsInfo)(root);
            this.enableRegistryCache('projectAddonsInfoInitialized');
            this.project.invalidateRegistry();
        }
        if (!this.meta.componentsRegistryInitialized) {
            await mListComponents(this.project);
            this.enableRegistryCache('componentsRegistryInitialized');
        }
        if (!this.meta.podComponentsRegistryInitialized) {
            await mListPodsComponents(this.project);
            this.enableRegistryCache('podComponentsRegistryInitialized');
        }
        const registry = this.project.registry;
        return uniqBy(items
            .concat(Object.keys(registry.component).map((rawName) => {
            return {
                label: rawName,
                data: {
                    files: registry.component[rawName],
                },
                kind: node_1.CompletionItemKind.Class,
                detail: 'component',
            };
        }))
            .map((item) => {
            return Object.assign({}, item, {
                label: (0, normalizers_1.normalizeToAngleBracketComponent)(item.label),
            });
        }), 'label');
    }
    async templateContextLookup(rawCurrentFilePath, templateContent) {
        var _a;
        const fsPath = vscode_uri_1.URI.parse(rawCurrentFilePath).fsPath;
        const componentName = (_a = this.project.matchPathToType(fsPath)) === null || _a === void 0 ? void 0 : _a.name;
        // todo - add branching for route templates support
        if (!componentName) {
            return [];
        }
        const maybeScripts = (0, template_definition_provider_1.getPathsFromRegistry)('component', componentName, this.registry).filter((el) => !(0, layout_helpers_1.isTestFile)(el) && (0, layout_helpers_1.isScriptPath)(el));
        const items = await (0, template_context_provider_1.componentsContextData)(this.server.fs, maybeScripts, templateContent);
        return items;
    }
    async getLocalPathExpressionCandidates(uri, originalText) {
        const candidates = await this.templateContextLookup(uri, originalText);
        return candidates;
    }
    async getMustachePathCandidates(root) {
        if (!this.meta.projectAddonsInfoInitialized) {
            await (0, layout_helpers_1.mGetProjectAddonsInfo)(root);
            this.enableRegistryCache('projectAddonsInfoInitialized');
            this.project.invalidateRegistry();
        }
        if (!this.meta.componentsRegistryInitialized) {
            await mListComponents(this.project);
            this.enableRegistryCache('componentsRegistryInitialized');
        }
        if (!this.meta.podComponentsRegistryInitialized) {
            await mListPodsComponents(this.project);
            this.enableRegistryCache('podComponentsRegistryInitialized');
        }
        if (!this.meta.helpersRegistryInitialized) {
            await mListHelpers(this.project);
            this.enableRegistryCache('helpersRegistryInitialized');
        }
        const registry = this.project.registry;
        const candidates = [
            ...Object.keys(registry.component).map((rawName) => {
                return {
                    label: rawName,
                    data: {
                        files: registry.component[rawName],
                    },
                    kind: node_1.CompletionItemKind.Class,
                    detail: 'component',
                };
            }),
            ...Object.keys(registry.helper).map((rawName) => {
                return {
                    label: rawName,
                    kind: node_1.CompletionItemKind.Function,
                    data: {
                        files: registry.helper[rawName],
                    },
                    detail: 'helper',
                };
            }),
        ];
        return candidates;
    }
    async getBlockPathCandidates(root) {
        if (!this.meta.projectAddonsInfoInitialized) {
            await (0, layout_helpers_1.mGetProjectAddonsInfo)(root);
            this.enableRegistryCache('projectAddonsInfoInitialized');
            this.project.invalidateRegistry();
        }
        if (!this.meta.componentsRegistryInitialized) {
            await mListComponents(this.project);
            this.enableRegistryCache('componentsRegistryInitialized');
        }
        if (!this.meta.podComponentsRegistryInitialized) {
            await mListPodsComponents(this.project);
            this.enableRegistryCache('podComponentsRegistryInitialized');
        }
        const registry = this.project.registry;
        return Object.keys(registry.component).map((rawName) => {
            return {
                label: rawName,
                data: {
                    files: registry.component[rawName],
                },
                kind: node_1.CompletionItemKind.Class,
                detail: 'component',
            };
        });
    }
    async getSubExpressionPathCandidates() {
        if (!this.meta.helpersRegistryInitialized) {
            await mListHelpers(this.project);
            this.enableRegistryCache('helpersRegistryInitialized');
        }
        if (!this.meta.projectAddonsInfoInitialized) {
            await (0, layout_helpers_1.mGetProjectAddonsInfo)(this.project.root);
            this.enableRegistryCache('projectAddonsInfoInitialized');
            this.project.invalidateRegistry();
        }
        const registry = this.project.registry;
        return Object.keys(registry.helper).map((helperName) => {
            return {
                label: helperName,
                data: {
                    files: registry.helper[helperName],
                },
                kind: node_1.CompletionItemKind.Function,
                detail: 'helper',
            };
        });
    }
    getExtendedScopedValues(focusPath) {
        const scopedValues = this.getScopedValues(focusPath, true);
        const extras = [];
        const allTokens = (0, usages_api_1.getAllTemplateTokens)().component;
        scopedValues.forEach((value) => {
            var _a;
            const data = (_a = value.data) !== null && _a !== void 0 ? _a : {};
            delete value.data;
            const componentName = data.componentName;
            if (!componentName) {
                return;
            }
            if (!(componentName in allTokens)) {
                return;
            }
            // get yield metadata from found component
            const meta = allTokens[componentName];
            // if we have yield scopes for meta, address it
            if (typeof meta.yieldScopes === 'object') {
                Object.keys(meta.yieldScopes).forEach((yieldScope) => {
                    // todo - respect yield name
                    /*
                    {
                        'default:0:Foo': ['component', 'foo-bar'],
                        'default:0:Bar': ['component', 'bar-baz'],
                        'default:0:Baz': ['component', 'baz-boo'],
                      }
                  */
                    var _a, _b;
                    const metaForScope = (_b = (_a = meta.yieldScopes) === null || _a === void 0 ? void 0 : _a[yieldScope]) !== null && _b !== void 0 ? _b : null;
                    const [slotName, index, key] = yieldScope.split(':');
                    if (slotName === data.slotName && `${data.index}` === index) {
                        const label = key.length ? `${value.label}.${key}` : `${value.label}`;
                        const item = { ...value, label };
                        if (metaForScope !== null) {
                            item.documentation = `${metaForScope[0]} ${JSON.stringify(metaForScope[1])}`;
                        }
                        extras.push(item);
                    }
                });
            }
        });
        return [...scopedValues, ...extras];
    }
    getScopedValues(focusPath, withMeta = false) {
        const scopedValues = (0, glimmer_utils_1.getLocalScope)(focusPath).map(({ name, node, path, componentName, slotName, index }) => {
            var _a;
            const key = node.type === 'ElementNode'
                ? node.tag
                : (_a = (path.parentPath && path.parentPath.node.path.original)) !== null && _a !== void 0 ? _a : 'unknown';
            const blockSource = node.type === 'ElementNode' ? `<${key} as |...|>` : `{{#${key} as |...|}}`;
            const result = {
                label: name,
                kind: node_1.CompletionItemKind.Variable,
                detail: `Positional param from ${blockSource}`,
            };
            if (withMeta) {
                result.data = {
                    componentName,
                    slotName,
                    index,
                };
            }
            return result;
        });
        return scopedValues;
    }
    async getAllModifiers(root) {
        if (!this.meta.modifiersRegistryInitialized) {
            await mListModifiers(this.project);
            this.enableRegistryCache('modifiersRegistryInitialized');
        }
        if (!this.meta.projectAddonsInfoInitialized) {
            await (0, layout_helpers_1.mGetProjectAddonsInfo)(root);
            this.enableRegistryCache('projectAddonsInfoInitialized');
            this.project.invalidateRegistry();
        }
        const registry = this.project.registry;
        const resolvedModifiers = Object.keys(registry.modifier).map((name) => {
            return {
                label: name,
                data: {
                    files: registry.modifier[name],
                },
                kind: node_1.CompletionItemKind.Function,
                detail: 'modifier',
            };
        });
        return uniqBy([...ember_helpers_1.emberModifierItems, ...resolvedModifiers, ...(0, layout_helpers_1.builtinModifiers)()], 'label');
    }
    async getParentComponentYields(node) {
        if (node.type !== 'ElementNode') {
            return [];
        }
        const paths = [];
        const rawScopedPaths = (0, template_definition_provider_1.provideComponentTemplatePaths)(this.registry, node.tag);
        rawScopedPaths.forEach((p) => {
            if (!paths.includes(p)) {
                paths.push(p);
            }
        });
        if (!paths.length) {
            return [];
        }
        const tpl = paths[0];
        const content = await this.server.fs.readFile(tpl);
        if (content === null) {
            return [];
        }
        try {
            return (0, template_tokens_collector_1.getTemplateBlocks)(content).map((blockName) => {
                return {
                    label: `:${blockName}`,
                    kind: node_1.CompletionItemKind.Variable,
                    detail: `Named block (Slot) for <${node.tag}>`,
                };
            });
        }
        catch (e) {
            return [];
        }
    }
    async onComplete(root, params) {
        var _a, _b, _c, _d, _e;
        (0, logger_1.logDebugInfo)('provideCompletions');
        if (params.type !== 'template') {
            return params.results;
        }
        const completions = params.results;
        const focusPath = params.focusPath;
        const uri = params.textDocument.uri;
        const originalText = params.originalText || '';
        try {
            if ((0, ast_helpers_1.isSpecialHelperStringPositionalParam)('component', focusPath)) {
                // (component "foo...")
                const items = await this.getMustachePathCandidates(root);
                completions.push(...items.filter((el) => el.detail === 'component'));
            }
            else if ((0, ast_helpers_1.isSpecialHelperStringPositionalParam)('helper', focusPath)) {
                const ignoredHelpers = ['helper', 'modifier', 'component'];
                // (component "foo...")
                const items = await this.getMustachePathCandidates(root);
                completions.push(...items.filter((el) => el.detail === 'helper' && !ignoredHelpers.includes(el.label)));
            }
            else if ((0, ast_helpers_1.isSpecialHelperStringPositionalParam)('modifier', focusPath)) {
                // (component "foo...")
                const items = await this.getAllModifiers(root);
                const ignoredHelpers = ['helper', 'modifier', 'component'];
                completions.push(...items.filter((el) => !ignoredHelpers.includes(el.label)));
            }
            else if ((0, ast_helpers_1.isNamedBlockName)(focusPath)) {
                (0, logger_1.logDebugInfo)('isNamedBlockName');
                // <:main>
                const yields = await this.getParentComponentYields(focusPath.parent);
                completions.push(...yields);
            }
            else if ((0, ast_helpers_1.isAngleComponentPath)(focusPath) && !(0, ast_helpers_1.isNamedBlockName)(focusPath)) {
                (0, logger_1.logDebugInfo)('isAngleComponentPath');
                // <Foo>
                const candidates = await this.getAllAngleBracketComponents(root);
                const scopedValues = this.getExtendedScopedValues(focusPath);
                (0, logger_1.logDebugInfo)(candidates, scopedValues);
                completions.push(...uniqBy([...candidates, ...scopedValues], 'label'));
            }
            else if ((0, ast_helpers_1.isScopedAngleTagName)(focusPath)) {
                // {{#let foo as |bar|}} <bar..
                const scopedValues = this.getExtendedScopedValues(focusPath);
                (0, logger_1.logDebugInfo)(scopedValues);
                completions.push(...uniqBy(scopedValues, 'label'));
            }
            else if ((0, ast_helpers_1.isElementAttribute)(focusPath) && focusPath.node.name.startsWith('.')) {
                (0, logger_1.logDebugInfo)('isElementAttribute');
                const attrName = '...attributes';
                if (!focusPath.parent.attributes.find((attr) => attr.name === attrName)) {
                    completions.push({
                        label: attrName,
                        documentation: (0, autocomplete_1.docForAttribute)(attrName),
                        kind: node_1.CompletionItemKind.Property,
                    });
                }
            }
            else if ((0, ast_helpers_1.isComponentArgumentName)(focusPath)) {
                (0, logger_1.logDebugInfo)('isComponentArgumentName');
                // <Foo @name.. />
                const maybeComponentName = focusPath.parent.tag;
                const isValidComponent = !['Input', 'Textarea', 'LinkTo'].includes(maybeComponentName) &&
                    !isArgumentName(maybeComponentName) &&
                    !maybeComponentName.startsWith(':') &&
                    !maybeComponentName.includes('.');
                if (isValidComponent) {
                    const tpls = [];
                    const localtpls = (0, template_definition_provider_1.provideComponentTemplatePaths)(this.registry, maybeComponentName);
                    localtpls.forEach((item) => {
                        if (!tpls.includes(item)) {
                            tpls.push(item);
                        }
                    });
                    const existingTpls = await (0, layout_helpers_1.asyncFilter)(tpls, this.server.fs.exists);
                    if (existingTpls.length) {
                        const existingAttributes = focusPath.parent.attributes.map((attr) => attr.name).filter((name) => isArgumentName(name));
                        const content = await this.server.fs.readFile(existingTpls[0]);
                        if (content !== null) {
                            const candidates = await this.getLocalPathExpressionCandidates(tpls[0], content);
                            const preResults = [];
                            candidates.forEach((obj) => {
                                const name = obj.label.split('.')[0];
                                if (isArgumentName(name) && !existingAttributes.includes(name)) {
                                    preResults.push({
                                        label: name,
                                        detail: obj.detail,
                                        kind: obj.kind,
                                    });
                                }
                            });
                            if (preResults.length) {
                                completions.push(...uniqBy(preResults, 'label'));
                            }
                        }
                    }
                }
            }
            else if ((0, ast_helpers_1.isLocalPathExpression)(focusPath)) {
                // {{foo-bar this.na?}}
                (0, logger_1.logDebugInfo)('isLocalPathExpression');
                const rawCandidates = await this.getLocalPathExpressionCandidates(uri, originalText);
                const candidates = rawCandidates.filter((el) => {
                    return el.label.startsWith('this.');
                });
                completions.push(...uniqBy(candidates, 'label'));
            }
            else if ((0, ast_helpers_1.isArgumentPathExpression)(focusPath)) {
                (0, logger_1.logDebugInfo)('isArgumentPathExpression');
                // {{@ite..}}
                const rawCandidates = await this.getLocalPathExpressionCandidates(uri, originalText);
                const candidates = rawCandidates.filter((el) => {
                    return isArgumentName(el.label);
                });
                completions.push(...uniqBy(candidates, 'label'));
            }
            else if ((0, ast_helpers_1.isMustachePath)(focusPath)) {
                // {{foo-bar?}}
                (0, logger_1.logDebugInfo)('isMustachePath');
                const candidates = await this.getMustachePathCandidates(root);
                const localCandidates = await this.getLocalPathExpressionCandidates(uri, originalText);
                if ((0, ast_helpers_1.isScopedPathExpression)(focusPath)) {
                    const scopedValues = this.getExtendedScopedValues(focusPath);
                    completions.push(...uniqBy(scopedValues, 'label'));
                }
                completions.push(...uniqBy(localCandidates, 'label'));
                completions.push(...uniqBy(candidates, 'label'));
                completions.push(...ember_helpers_1.emberMustacheItems);
            }
            else if ((0, ast_helpers_1.isBlockPath)(focusPath)) {
                // {{#foo-bar?}} {{/foo-bar}}
                (0, logger_1.logDebugInfo)('isBlockPath');
                const candidates = await this.getBlockPathCandidates(root);
                if ((0, ast_helpers_1.isScopedPathExpression)(focusPath)) {
                    const scopedValues = this.getScopedValues(focusPath);
                    completions.push(...uniqBy(scopedValues, 'label'));
                }
                completions.push(...ember_helpers_1.emberBlockItems);
                completions.push(...uniqBy(candidates, 'label'));
            }
            else if ((0, ast_helpers_1.isSubExpressionPath)(focusPath)) {
                // {{foo-bar name=(subexpr? )}}
                (0, logger_1.logDebugInfo)('isSubExpressionPath');
                const candidates = await this.getSubExpressionPathCandidates();
                completions.push(...uniqBy(candidates, 'label'));
                completions.push(...ember_helpers_1.emberSubExpressionItems);
            }
            else if ((0, ast_helpers_1.isPathExpression)(focusPath)) {
                (0, logger_1.logDebugInfo)('isPathExpression');
                if ((0, ast_helpers_1.isScopedPathExpression)(focusPath)) {
                    const scopedValues = this.getExtendedScopedValues(focusPath);
                    completions.push(...uniqBy(scopedValues, 'label'));
                }
                const candidates = await this.getLocalPathExpressionCandidates(uri, originalText);
                completions.push(...uniqBy(candidates, 'label'));
            }
            else if ((0, ast_helpers_1.isLinkToTarget)(focusPath)) {
                // {{link-to "name" "target?"}}, {{#link-to "target?"}} {{/link-to}}
                (0, logger_1.logDebugInfo)('isLinkToTarget');
                if (!this.meta.routesRegistryInitialized) {
                    await mListRoutes(this.project);
                    this.enableRegistryCache('routesRegistryInitialized');
                }
                const registry = this.project.registry;
                const results = Object.keys(registry.routePath).map((name) => {
                    return {
                        label: name,
                        kind: node_1.CompletionItemKind.File,
                        detail: 'route',
                    };
                });
                completions.push(...results);
            }
            else if ((0, ast_helpers_1.isLinkComponentRouteTarget)(focusPath)) {
                // <LinkTo @route="foo.." />
                (0, logger_1.logDebugInfo)('isLinkComponentRouteTarget');
                if (!this.meta.routesRegistryInitialized) {
                    await mListRoutes(this.project);
                    this.enableRegistryCache('routesRegistryInitialized');
                }
                const registry = this.project.registry;
                const results = Object.keys(registry.routePath).map((name) => {
                    return {
                        label: name,
                        kind: node_1.CompletionItemKind.File,
                        detail: 'route',
                    };
                });
                completions.push(...results);
            }
            else if ((0, ast_helpers_1.isModifierPath)(focusPath)) {
                (0, logger_1.logDebugInfo)('isModifierPath');
                const modifiers = await this.getAllModifiers(root);
                completions.push(...modifiers);
            }
            else if ((0, ast_helpers_1.isHashPair)(focusPath)) {
                // {{#each key=}}
                (0, logger_1.logDebugInfo)('isHashPair');
                const grandPaparentNode = (_b = (_a = focusPath.parentPath) === null || _a === void 0 ? void 0 : _a.parentPath) === null || _b === void 0 ? void 0 : _b.node;
                if (grandPaparentNode && grandPaparentNode.type === 'BlockStatement') {
                    if ((0, ast_helpers_1.isPathExpression)(grandPaparentNode.path)) {
                        const name = grandPaparentNode.path.original;
                        completions.push(...(0, autocomplete_1.argumentsForBuiltinComponent)(name).map((el) => {
                            return {
                                label: el.label,
                                kind: node_1.CompletionItemKind.Property,
                                documentation: el.documentation,
                            };
                        }));
                    }
                }
            }
            else if ((0, ast_helpers_1.isHashPairValue)(focusPath)) {
                // {{#each key=value}} {{/each}}
                (0, logger_1.logDebugInfo)('isHashPairValue');
                const grandPaparentNode = (_e = (_d = (_c = focusPath.parentPath) === null || _c === void 0 ? void 0 : _c.parentPath) === null || _d === void 0 ? void 0 : _d.parentPath) === null || _e === void 0 ? void 0 : _e.node;
                if (grandPaparentNode && grandPaparentNode.type === 'BlockStatement' && (0, ast_helpers_1.isPathExpression)(grandPaparentNode.path)) {
                    const name = grandPaparentNode.path.original;
                    completions.push(...(0, autocomplete_1.valuesForBuiltinComponentArgument)(name, focusPath.parent.key).map((el) => {
                        return {
                            label: el.label,
                            kind: node_1.CompletionItemKind.Value,
                            documentation: el.documentation,
                        };
                    }));
                }
            }
            else {
                (0, logger_1.logDebugInfo)('no match');
            }
        }
        catch (e) {
            (0, logger_1.logError)(e);
        }
        if (this.hasNamespaceSupport) {
            const hasSomeComponents = completions.some((completion) => completion.detail === 'component');
            if (hasSomeComponents) {
                const resultsMap = generateNamespacedComponentsHashMap(this.project.addonsMeta, this.server, (0, ast_helpers_1.isAngleComponentPath)(focusPath));
                const newCompletions = [];
                // Iterate over the completions and add name spaced labels if applicable.
                completions.forEach((completionItem) => {
                    const matchingLabels = resultsMap[completionItem.label];
                    if (matchingLabels) {
                        matchingLabels.forEach((labelItem) => {
                            const completionObj = { ...completionItem };
                            completionObj.label = labelItem;
                            newCompletions.push(completionObj);
                        });
                    }
                    else {
                        newCompletions.push(completionItem);
                    }
                });
                return newCompletions;
            }
        }
        return completions;
    }
}
exports.default = TemplateCompletionProvider;
//# sourceMappingURL=template-completion-provider.js.map