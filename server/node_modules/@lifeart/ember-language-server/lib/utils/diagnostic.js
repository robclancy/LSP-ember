"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toDiagnostic = exports.toHbsSource = void 0;
const node_1 = require("vscode-languageserver/node");
const ParseErrorExp = /^Parse error on line (\d+)/;
const OnLineErrorExp = / \(on line (\d+)\)\.$/;
function toHbsSource(templateNode) {
    let lastParsedLine = 1;
    const sortedTemplateNodes = [templateNode];
    const output = sortedTemplateNodes.reduce((acc, node) => {
        const verticalGap = lastParsedLine < node.startLine ? '\n'.repeat(node.startLine - lastParsedLine) : '';
        const indentation = node.startColumn > 1 && !node.template.startsWith('\n') ? ' '.repeat(node.startColumn) : '';
        // We have to remove the trailing whitespace(s) after the last new line `\n` for **mutliline inline template(s)**
        // otherwise, we will have trailing whitespace lint error !!
        const rightTrimmedTemplate = node.template.replace(/(\n)[ ]+$/, (_, newLine) => newLine);
        lastParsedLine = node.endLine;
        acc += verticalGap + indentation + rightTrimmedTemplate;
        return acc;
    }, '');
    return output;
}
exports.toHbsSource = toHbsSource;
function convertEmberTemplateLintSeverity(value) {
    // lint values
    const TODO_SEVERITY = -1;
    const IGNORE_SEVERITY = 0;
    const WARNING_SEVERITY = 1;
    const ERROR_SEVERITY = 2;
    if (value === TODO_SEVERITY) {
        return node_1.DiagnosticSeverity.Hint;
    }
    else if (value === ERROR_SEVERITY) {
        return node_1.DiagnosticSeverity.Error;
    }
    else if (value === WARNING_SEVERITY) {
        return node_1.DiagnosticSeverity.Warning;
    }
    else if (value === IGNORE_SEVERITY) {
        return node_1.DiagnosticSeverity.Information;
    }
    return node_1.DiagnosticSeverity.Error;
}
function severityForError(error) {
    if (error.rule) {
        return convertEmberTemplateLintSeverity(error.severity);
    }
    else {
        return node_1.DiagnosticSeverity.Error;
    }
}
function toDiagnostic(source, error) {
    const result = {
        severity: severityForError(error),
        range: toRange(source, error),
        message: toMessage(error),
        code: error.rule || 'syntax',
        source: error.rule ? 'ember-template-lint' : 'glimmer-engine',
    };
    if (result.source === 'ember-template-lint') {
        result.codeDescription = {
            href: `https://github.com/ember-template-lint/ember-template-lint/blob/master/docs/rule/${result.code}.md`,
        };
    }
    return result;
}
exports.toDiagnostic = toDiagnostic;
function toLineRange(source, idx) {
    const line = (source.split('\n')[idx] || '').replace(/\s+$/, '');
    const pre = line.match(/^(\s*)/);
    const start = pre ? pre[1].length : 0;
    const end = line.length || start + 1;
    return [start, end];
}
function toMessage({ message, isFixable }) {
    if (ParseErrorExp.test(message)) {
        return message.split('\n').pop() || '';
    }
    message = message.replace(OnLineErrorExp, '');
    if (isFixable) {
        message = `${message} (fixable)`;
    }
    return message;
}
function toRange(source, error) {
    let line;
    let column;
    const match = error.message.match(ParseErrorExp) || error.message.match(OnLineErrorExp);
    if (match) {
        line = Number(match[1]) - 1;
    }
    else if (error.line) {
        line = error.line - 1;
    }
    else {
        line = 0;
    }
    const [start, end] = toLineRange(source, line);
    if (typeof error.column === 'number') {
        column = error.column;
    }
    else {
        column = start;
    }
    return {
        start: { line, character: column },
        end: { line, character: end },
    };
}
//# sourceMappingURL=diagnostic.js.map