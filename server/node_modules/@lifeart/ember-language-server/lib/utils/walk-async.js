// async implementation of https://github.com/joliss/node-walk-sync/blob/master/index.ts
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Entry = exports.entries = void 0;
const path = require("path");
const pm = require("picomatch");
// @ts-expect-error esmodule
const flatten = require("lodash/flatten");
const fs_utils_1 = require("./fs-utils");
function ensurePosix(filepath) {
    if (path.sep !== '/') {
        return filepath.split(path.sep).join('/');
    }
    return filepath;
}
class MatcherCollection {
    constructor(matchers) {
        this.matchers = [pm(matchers)];
    }
    match(value) {
        for (let i = 0; i < this.matchers.length; i++) {
            if (this.matchers[i](value)) {
                return true;
            }
        }
        return false;
    }
}
async function walkAsync(baseDir, inputOptions) {
    const options = handleOptions(inputOptions);
    let mapFunct;
    if (options.includeBasePath) {
        mapFunct = function (entry) {
            return entry.basePath.split(path.sep).join('/').replace(/\/+$/, '') + '/' + entry.relativePath;
        };
    }
    else {
        mapFunct = function (entry) {
            return entry.relativePath;
        };
    }
    const pathSet = new Set();
    const data = await _walkAsync(baseDir, options, null, pathSet);
    try {
        return data.map(mapFunct);
    }
    finally {
        pathSet.clear();
    }
}
exports.default = walkAsync;
function entries(baseDir, inputOptions) {
    const options = handleOptions(inputOptions);
    return _walkAsync(ensurePosix(baseDir), options, null, new Set());
}
exports.entries = entries;
class Entry {
    constructor(relativePath, basePath, isDirectory) {
        this.relativePath = relativePath;
        this.basePath = basePath;
        this._isDirectory = isDirectory;
    }
    get fullPath() {
        return `${this.basePath}/${this.relativePath}`;
    }
    isDirectory() {
        return this._isDirectory;
    }
}
exports.Entry = Entry;
function isDefined(val) {
    return typeof val !== 'undefined';
}
function handleOptions(_options) {
    // @ts-expect-error empty options
    let options = {};
    if (Array.isArray(_options)) {
        options.globs = _options;
    }
    else if (_options) {
        options = _options;
    }
    return options;
}
function handleRelativePath(_relativePath) {
    if (_relativePath == null) {
        return '';
    }
    else if (_relativePath.slice(-1) !== '/') {
        return _relativePath + '/';
    }
    else {
        return _relativePath;
    }
}
function lexicographically(a, b) {
    const aPath = a.relativePath;
    const bPath = b.relativePath;
    if (aPath === bPath) {
        return 0;
    }
    else if (aPath < bPath) {
        return -1;
    }
    else {
        return 1;
    }
}
async function _walkAsync(baseDir, options, _relativePath, visited) {
    const fs = options.fs;
    const relativePath = handleRelativePath(_relativePath);
    const realPath = fs.hasRealFsAccess ? fs.realpathSync(baseDir + '/' + relativePath) : path.join(baseDir, '/', relativePath);
    if (visited.has(realPath)) {
        return [];
    }
    else {
        visited.add(realPath);
    }
    try {
        const ignorePatterns = options.ignore;
        const globs = options.globs;
        let globMatcher;
        let ignoreMatcher;
        if (ignorePatterns) {
            ignoreMatcher = new MatcherCollection(ignorePatterns);
        }
        if (globs) {
            globMatcher = new MatcherCollection(globs);
        }
        let names = [];
        try {
            names = await fs.readDirectory(baseDir + '/' + relativePath);
        }
        catch (e) {
            // EOL;
        }
        const rawEntries = names.map(async ([name, fType]) => {
            const entryRelativePath = relativePath + name;
            if (ignoreMatcher && ignoreMatcher.match(entryRelativePath)) {
                return;
            }
            if (fType === fs_utils_1.FileType.Directory) {
                return new Entry(entryRelativePath + '/', baseDir, true);
            }
            else if (fType === fs_utils_1.FileType.File || fType === fs_utils_1.FileType.SymbolicLink) {
                return new Entry(entryRelativePath, baseDir, false);
            }
        });
        const unfilteredEntries = await Promise.all(rawEntries);
        const entries = unfilteredEntries.filter(isDefined);
        const sortedEntries = entries.sort(lexicographically);
        const extras = [];
        for (let i = 0; i < sortedEntries.length; ++i) {
            const entry = sortedEntries[i];
            if (entry.isDirectory()) {
                if (options.directories !== false && (!globMatcher || globMatcher.match(entry.relativePath))) {
                    extras.push(entry);
                }
                extras.push(_walkAsync(baseDir, options, entry.relativePath, visited));
            }
            else {
                if (!globMatcher || globMatcher.match(entry.relativePath)) {
                    extras.push(entry);
                }
            }
        }
        const results = await Promise.all(extras);
        return flatten(results);
    }
    finally {
        // EOL
    }
}
//# sourceMappingURL=walk-async.js.map