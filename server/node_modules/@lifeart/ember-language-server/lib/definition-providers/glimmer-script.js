"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const glimmer_utils_1 = require("./../glimmer-utils");
const estree_utils_1 = require("./../estree-utils");
const addon_api_1 = require("./../utils/addon-api");
const syntax_1 = require("@glimmer/syntax");
const glimmer_script_1 = require("../utils/glimmer-script");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
class GlimmerScriptDefinitionProvider {
    constructor(server) {
        this.server = server;
    }
    async handle(params, project) {
        const uri = params.textDocument.uri;
        const { root } = project;
        const document = this.server.documents.get(uri);
        if (!document) {
            return null;
        }
        const content = document.getText();
        const ranges = (0, glimmer_script_1.getFileRanges)(content);
        let rangeWalker = new glimmer_script_1.RangeWalker(ranges);
        // strip not needed scopes example
        // strip not needed scopes example
        rangeWalker = rangeWalker.subtract(rangeWalker.hbsInlineComments(true));
        rangeWalker = rangeWalker.subtract(rangeWalker.hbsComments(true));
        rangeWalker = rangeWalker.subtract(rangeWalker.htmlComments(true));
        const templates = rangeWalker.templates(true);
        const templateForPosition = (0, glimmer_script_1.documentPartForPosition)(templates, params.position);
        if (templateForPosition) {
            // do logic to get more meta from js scope for template position
            // here we need glimmer logic to collect all available tokens from scope for autocomplete
            const templateDocument = vscode_languageserver_textdocument_1.TextDocument.create(uri, 'handlebars', document.version, templateForPosition.absoluteContent);
            const ast = (0, syntax_1.preprocess)(templateDocument.getText());
            const focusPath = glimmer_utils_1.default.toPosition(ast, (0, estree_utils_1.toPosition)(params.position), templateDocument.getText());
            if (!focusPath) {
                return null;
            }
            // @to-do likely we need to introduce one more type: "glimmerScript" to use scope values
            const definitions = await (0, addon_api_1.queryELSAddonsAPIChain)(project.builtinProviders.definitionProviders, root, {
                focusPath,
                type: 'template',
                textDocument: templateDocument,
                position: params.position,
                results: [],
                server: this.server,
            });
            const addonResults = await (0, addon_api_1.queryELSAddonsAPIChain)(project.providers.definitionProviders, root, {
                focusPath,
                type: 'template',
                textDocument: templateDocument,
                position: params.position,
                results: definitions,
                server: this.server,
            });
            return addonResults;
        }
        else {
            // looks like we could "fix" template and continue in script branch;
            return null;
        }
        // @to-do - figure out how to patch babel ast with hbs
        // or don't patch it, and just have 2 refs from hbs ast to scope of js ast
        // const ast = parse(cleanScript.content, {
        //   sourceType: 'module',
        // });
        // const astPath = ASTPath.toPosition(ast, toPosition(params.position), content);
        // if (!astPath) {
        //   return null;
        // }
        // const results: Location[] = await queryELSAddonsAPIChain(project.builtinProviders.definitionProviders, root, {
        //   focusPath: astPath,
        //   type: 'glimmerScript',
        //   textDocument: params.textDocument,
        //   position: params.position,
        //   results: [],
        //   server: this.server,
        // });
        // const addonResults = await queryELSAddonsAPIChain(project.providers.definitionProviders, root, {
        //   focusPath: astPath,
        //   type: 'glimmerScript',
        //   textDocument: params.textDocument,
        //   position: params.position,
        //   results,
        //   server: this.server,
        // });
        // return addonResults;
    }
}
exports.default = GlimmerScriptDefinitionProvider;
//# sourceMappingURL=glimmer-script.js.map