"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("vscode-languageserver/node");
const memoize = require("memoizee");
const logger_1 = require("../../utils/logger");
const ast_helpers_1 = require("../../utils/ast-helpers");
const layout_helpers_1 = require("../../utils/layout-helpers");
const mListRoutes = memoize(layout_helpers_1.listRoutes, { length: 1, maxAge: 60000 });
const mListModels = memoize(layout_helpers_1.listModels, { length: 1, maxAge: 60000 });
const mListServices = memoize(layout_helpers_1.listServices, { length: 1, maxAge: 60000 });
const mListTransforms = memoize(layout_helpers_1.listTransforms, { length: 1, maxAge: 60000 });
class ScriptCompletionProvider {
    constructor() {
        this.meta = {
            modelsRegistryInitialized: false,
            routesRegistryInitialized: false,
            servicesRegistryInitialized: false,
            projectAddonsInfoInitialized: false,
            transformsRegistryInitialized: false,
        };
    }
    enableRegistryCache(value) {
        if (this.server.flags.hasExternalFileWatcher) {
            this.meta[value] = true;
        }
        else {
            this.server.connection.console.warn('Unable to user global registry state, falling back to cache api, to fix this message install [els-addon-file-watcher]');
        }
    }
    get registry() {
        return this.project.registry;
    }
    async initRegistry(_, project) {
        this.project = project;
        this.server = _;
        if (project.flags.enableEagerRegistryInitialization) {
            try {
                const initStartTime = Date.now();
                await mListModels(project);
                this.enableRegistryCache('modelsRegistryInitialized');
                await mListServices(project);
                this.enableRegistryCache('servicesRegistryInitialized');
                (0, logger_1.logInfo)(project.root + ': script registry initialized in ' + (Date.now() - initStartTime) + 'ms');
            }
            catch (e) {
                (0, logger_1.logError)(e);
            }
        }
        else {
            (0, logger_1.logInfo)('EagerRegistryInitialization is disabled for "' + project.name + '" (script-completion-provider)');
        }
    }
    async onComplete(root, params) {
        const focusPath = params.focusPath;
        if (params.type !== 'script') {
            return params.results;
        }
        (0, logger_1.logDebugInfo)('script:onComplete');
        const completions = params.results;
        try {
            if ((0, ast_helpers_1.isStoreModelLookup)(focusPath) || (0, ast_helpers_1.isModelReference)(focusPath)) {
                (0, logger_1.logDebugInfo)('isStoreModelLookup || isModelReference');
                if (!this.meta.modelsRegistryInitialized) {
                    await mListModels(this.project);
                    this.enableRegistryCache('modelsRegistryInitialized');
                }
                if (!this.meta.projectAddonsInfoInitialized) {
                    await (0, layout_helpers_1.mGetProjectAddonsInfo)(root);
                    this.enableRegistryCache('projectAddonsInfoInitialized');
                    this.project.invalidateRegistry();
                }
                const registry = this.registry;
                Object.keys(registry.model).forEach((rawModelName) => {
                    completions.push({
                        kind: node_1.CompletionItemKind.Class,
                        detail: 'model',
                        label: rawModelName,
                    });
                });
            }
            else if ((0, ast_helpers_1.isRouteLookup)(focusPath)) {
                (0, logger_1.logDebugInfo)('isRouteLookup');
                if (!this.meta.routesRegistryInitialized) {
                    await mListRoutes(this.project);
                    this.enableRegistryCache('routesRegistryInitialized');
                }
                if (!this.meta.projectAddonsInfoInitialized) {
                    await (0, layout_helpers_1.mGetProjectAddonsInfo)(root);
                    this.enableRegistryCache('projectAddonsInfoInitialized');
                    this.project.invalidateRegistry();
                }
                const registry = this.registry;
                Object.keys(registry.routePath).forEach((rawRouteName) => {
                    completions.push({
                        kind: node_1.CompletionItemKind.File,
                        detail: 'route',
                        label: rawRouteName,
                    });
                });
            }
            else if ((0, ast_helpers_1.isNamedServiceInjection)(focusPath)) {
                (0, logger_1.logDebugInfo)('isNamedServiceInjection');
                if (!this.meta.servicesRegistryInitialized) {
                    await mListServices(this.project);
                    this.enableRegistryCache('servicesRegistryInitialized');
                }
                if (!this.meta.projectAddonsInfoInitialized) {
                    await (0, layout_helpers_1.mGetProjectAddonsInfo)(root);
                    this.enableRegistryCache('projectAddonsInfoInitialized');
                    this.project.invalidateRegistry();
                }
                const registry = this.registry;
                Object.keys(registry.service).forEach((rawServiceName) => {
                    completions.push({
                        kind: node_1.CompletionItemKind.Class,
                        detail: 'service',
                        label: rawServiceName,
                    });
                });
            }
            else if ((0, ast_helpers_1.isComputedPropertyArgument)(focusPath)) {
                (0, logger_1.logDebugInfo)('isComputedPropertyArgument');
                if (!focusPath.parentPath || !focusPath.parentPath.parentPath) {
                    return [];
                }
                const node = (0, ast_helpers_1.closestScriptNodeParent)(focusPath, 'ObjectExpression', ['ObjectProperty']) || (0, ast_helpers_1.closestScriptNodeParent)(focusPath, 'ClassBody');
                if (node === null) {
                    (0, logger_1.logDebugInfo)('isComputedPropertyArgument - unable to find keys');
                    return [];
                }
                (node.properties || node.body || []).forEach((property) => {
                    let name = null;
                    if (property.key.type === 'StringLiteral') {
                        name = property.key.value;
                    }
                    else if (property.key.type === 'Identifier') {
                        name = property.key.name;
                    }
                    if (name !== null) {
                        completions.push({
                            kind: 10,
                            label: name,
                            detail: 'ObjectProperty',
                        });
                    }
                });
            }
            else if ((0, ast_helpers_1.isTransformReference)(focusPath)) {
                (0, logger_1.logDebugInfo)('isTransformReference');
                if (!this.meta.transformsRegistryInitialized) {
                    await mListTransforms(this.project);
                    this.enableRegistryCache('transformsRegistryInitialized');
                }
                if (!this.meta.projectAddonsInfoInitialized) {
                    await (0, layout_helpers_1.mGetProjectAddonsInfo)(root);
                    this.enableRegistryCache('projectAddonsInfoInitialized');
                    this.project.invalidateRegistry();
                }
                const registry = this.registry;
                Object.keys(registry.transform).forEach((rawTransformName) => {
                    completions.push({
                        kind: node_1.CompletionItemKind.Function,
                        detail: 'transform',
                        label: rawTransformName,
                    });
                });
            }
        }
        catch (e) {
            (0, logger_1.logDebugInfo)('error', e);
        }
        (0, logger_1.logDebugInfo)('completions', completions);
        return completions;
    }
}
exports.default = ScriptCompletionProvider;
//# sourceMappingURL=script-completion-provider.js.map